start-symbol: file

include: {{
	#include <any>
	#include <memory>
	#include <type_traits>
	#include <iostream>

	#include <gsl/gsl>

	#include "string_heap.h"
	#include "ast.h"
	#include "parse_globals.h"
}}

code: {{
	using namespace idlc::parser;

	template<typename type>
	type to_int(const Value& v)
	{
		// FIXME: I know, precision bug
		static_assert(std::is_arithmetic_v<type>);
		return gsl::narrow<type>(reinterpret_cast<std::uintptr_t>(v.getValue()));
	}

	template<typename type>
	type to_ptr(const Value& v)
	{
		return static_cast<type>(const_cast<void*>(v.getValue()));
	}

	template<typename type>
	auto share(type&& v)
	{
		const auto ptr = std::make_shared<std::decay_t<type>>(v);
		parser_objs.emplace_back(ptr);
		return reinterpret_cast<const void*>(parser_objs.size() - 1);
	}

	template<typename type>
	std::shared_ptr<type> get_shared(const Value& v)
	{
		if (!v.getValue()) {
			return nullptr;
		}

		const auto id = to_int<std::size_t>(v);
		return std::any_cast<std::shared_ptr<type>>(gsl::at(parser_objs, id));
	}
}}

# Our design is simple: we keep a parser-global vector of shared_ptrs to every node we ever build, ensuring that cached
# nodes live long enough

rules:

# LEXING: These are the logical "tokens" of the language

tok_kw_const = "const"
tok_kw_string = "string"
tok_kw_projection = "projection"
tok_kw_rpc = "rpc"
tok_kw_driver = "driver"
tok_kw_module = "module"
tok_kw_header = "header"
tok_kw_import = "import"
tok_kw_struct = "struct"
tok_kw_union = "union"
tok_kw_char = "char"
tok_kw_bool = "bool"
tok_kw_short = "short"
tok_kw_int = "int"
tok_kw_long = "long"
tok_kw_signed = "signed"
tok_kw_unsigned = "unsigned"
tok_kw_void = "void"
tok_kw_include = "include"
tok_kw_array = "array"
tok_kw_null = "null"
tok_kw_this = "this"
tok_kw_in = "in"
tok_kw_out = "out"
tok_kw_alloc = "alloc"
tok_kw_dealloc = "dealloc"
tok_kw_bind = "bind"
tok_kw_caller = "caller"
tok_kw_callee = "callee"
tok_kw_any_of = "any_of"

tok_space = lex_blank+
tok_arrow = "->"
tok_langle = "<"
tok_rangle = ">"
tok_lbrace = "{"
tok_rbrace = "}"
tok_lbrack = "["
tok_rbrack = "]"
tok_lpar = "("
tok_rpar = ")"
tok_star = "*"
tok_semi = ";"
tok_comma = ","

tok_path = "<" chars:lex_path_char+ ">" {{
	std::string path {};
	for (const auto& c : chars.getValues())
		path += to_int<char>(c);

	value = idents.intern(path);
}}

tok_string = <ascii 34> chars:lex_string_char* <ascii 34> {{
	std::string path {};
	for (const auto& c : chars.getValues())
		path += to_int<char>(c);

	value = idents.intern(path);
}}

tok_number = digits:[0123456789]+ {{
	std::uint64_t n {};
	for (const auto& d : digits.getValues()) {
		n *= 10;
		n += to_int<char>(d) - '0';
	}

	value = reinterpret_cast<void*>(n);
}}

tok_ident = lex_ident_start rest:lex_ident_rest* {{
	std::string ident {};
	ident += to_int<char>($1);
	for (const auto& c : rest.getValues())
		ident += to_int<char>(c);

	value = idents.intern(ident);
}}

lex_path_char = [ !\"#$%&\'()*+,-./0123456789:;<=?@ABCDEFGHIJKLMNOPQRSTUVWXYZ[\\^_`abcdefghijklmnopqrstuvwxyz{|}~] | <ascii 93>
lex_string_char = [ !#$%&\'()*+,-./0123456789:;<=>?@ABCDEFGHIJKLMNOPQRSTUVWXYZ[\\^_`abcdefghijklmnopqrstuvwxyz{|}~] | <ascii 93>
lex_block_comment_char = [ !\"#$%&\'()*+,-./0123456789:;<=>?@ABCDEFGHIJKLMNOPQRSTUVWXYZ[\\^_`abcdefghijklmnopqrstuvwxyz{|}~] | lex_whitespace | <ascii 93>
lex_line_comment_char = [ !\"#$%&\'()*+,-./0123456789:;<=>?@ABCDEFGHIJKLMNOPQRSTUVWXYZ[\\^_`abcdefghijklmnopqrstuvwxyz{|}~] | [ \t] | <ascii 93>
lex_whitespace = [ \t\n\r]

lex_line_comment = "//" lex_line_comment_char* "\n"
lex_block_comment = "/*" lex_block_comment_char* "*/"
lex_comment = lex_line_comment | lex_block_comment
lex_blank = lex_whitespace+ | lex_comment

lex_ident_start = [_abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ]
lex_ident_rest = [01234567890] | lex_ident_start

# PARSER

file = dfile:driver_file {{ value = share(file {get_shared<driver_file>(dfile)}); }} | module_file

driver_file = former:(tok_space? include_list)? tok_space? driver:driver_def latter:(tok_space? include_list)? tok_space? <eof> {{
	const auto former_ptr = get_shared<std::vector<gsl::czstring<>>>(former);
	const gsl::not_null driver_ptr {get_shared<driver_def>(driver)};
	const auto latter_ptr = get_shared<std::vector<gsl::czstring<>>>(latter);
	value = share(driver_file {former_ptr, driver_ptr, latter_ptr});
}}

include_list = first:include_stmt next:(tok_space? include_stmt)* {{
	const auto& next_vals = next.getValues();
	std::vector<gsl::czstring<>> paths {};
	paths.reserve(1 + next_vals.size());
	paths.emplace_back(to_ptr<gsl::czstring<>>(first));
	for (const auto& p : next_vals)
		paths.emplace_back(to_ptr<gsl::czstring<>>(p));

	value = share(std::move(paths));
}}

include_stmt = tok_kw_include tok_space? path:tok_path tok_space? tok_semi {{
	value = path;
}}

driver_def = tok_kw_driver tok_space name:tok_ident tok_space? tok_lbrace imports:(tok_space? import_list)? tok_space? tok_rbrace {{
	const auto name_val = to_ptr<gsl::czstring<>>(name);	
	const auto imports_ptr = get_shared<std::vector<gsl::czstring<>>>(imports);
	value = share(driver_def {name_val, imports_ptr});
}}

import_list = first:import_stmt next:(tok_space? import_stmt)* {{
	const auto& next_vals = next.getValues();
	std::vector<gsl::czstring<>> idents {};
	idents.reserve(1 + next_vals.size());
	idents.emplace_back(to_ptr<gsl::czstring<>>(first));
	for (const auto& id : next_vals)
		idents.emplace_back(to_ptr<gsl::czstring<>>(id));

	value = share(std::move(idents));
}}

import_stmt = tok_kw_import tok_space ident:tok_ident tok_space? tok_semi {{ value = ident; }}

module_file = tok_space? module_list tok_space? <eof>

module_list = module_def (tok_space? module_def)*

module_def = tok_kw_module tok_space tok_ident tok_space? tok_lbrace (tok_space? module_item_list)? tok_space? tok_rbrace

module_item_list = module_item (tok_space? module_item)*

module_item = header_stmt | proj_def | rpc_def

header_stmt = tok_kw_header tok_space? tok_path tok_space? tok_semi
	| tok_kw_header tok_space? tok_string tok_space? tok_semi

proj_def = tok_kw_projection tok_space? tok_langle tok_space? proj_type tok_space? tok_rangle tok_space? tok_ident tok_space? tok_lbrace (tok_space? proj_field_list)? tok_space? tok_rbrace

proj_type = proj_struct_type | proj_union_type

proj_struct_type = tok_kw_struct tok_space tok_ident

proj_union_type = tok_kw_union tok_space tok_ident tok_space? tok_comma tok_space? field_ref

field_ref = field_abs_ref | field_rel_ref

field_rel_ref = tok_ident (tok_arrow tok_ident)*

field_abs_ref = tok_kw_this (tok_arrow field_rel_ref)?

proj_field_list = proj_field (tok_space? proj_field)*

proj_field = var_decl tok_space? tok_semi

var_decl = tyname tok_space? tok_ident

val_attr = tok_kw_in | tok_kw_out

rpc_side_spec = tok_kw_caller | tok_kw_callee

rpc_side_paren_expr = tok_lpar tok_space? rpc_side_spec tok_space? tok_rpar

ptr_attr = tok_kw_in
	| tok_kw_out
	| tok_kw_alloc (tok_space? rpc_side_paren_expr)?
	| tok_kw_dealloc (tok_space? rpc_side_paren_expr)?
	| tok_kw_bind (tok_space? rpc_side_paren_expr)?

val_attrs = tok_lbrack tok_space? val_attr_list tok_space? tok_rbrack

ptr_attrs = tok_lbrack tok_space? ptr_attr_list tok_space? tok_rbrack

val_attr_list = val_attr (tok_space? tok_comma tok_space? val_attr)*

ptr_attr_list = ptr_attr (tok_space? tok_comma tok_space? ptr_attr)*

# HACK: we sort these alternates by length to get the parser to greedy-match them
# NOTE: we don't need type spacing rules for parsing since that parse will just fail in contexts where it's needed
# We'd only need if we were generating it, and even then we'd just pessimistically insert spaces anyways

tyname_arith = tok_kw_unsigned tok_space tok_kw_long tok_space tok_kw_long {{ 
	value = reinterpret_cast<void*>(tyname_arith::ty_ullong);
}} | tok_kw_unsigned tok_space tok_kw_long {{
	value = reinterpret_cast<void*>(tyname_arith::ty_ulong);
}} | tok_kw_long tok_space tok_kw_long {{
	value = reinterpret_cast<void*>(tyname_arith::ty_llong);
}} | tok_kw_unsigned tok_space tok_kw_int {{
	value = reinterpret_cast<void*>(tyname_arith::ty_uint);
}} | tok_kw_unsigned tok_space tok_kw_short {{
	value = reinterpret_cast<void*>(tyname_arith::ty_ushort);
}} | tok_kw_unsigned tok_space tok_kw_char {{
	value = reinterpret_cast<void*>(tyname_arith::ty_uchar);
}} | tok_kw_signed tok_space tok_kw_char {{
	value = reinterpret_cast<void*>(tyname_arith::ty_schar);
}} | tok_kw_short {{
	value = reinterpret_cast<void*>(tyname_arith::ty_short);
}} | tok_kw_int {{
	value = reinterpret_cast<void*>(tyname_arith::ty_int);
}} | tok_kw_long {{
	value = reinterpret_cast<void*>(tyname_arith::ty_long);
}} | tok_kw_char {{
	value = reinterpret_cast<void*>(tyname_arith::ty_char);
}} | tok_kw_bool {{
	value = reinterpret_cast<void*>(tyname_arith::ty_bool);
}}

# Do note that there is very little difference between const array<int, 10> and array<const int, 10>.
tyname_array = tok_kw_array tok_space? tok_langle tok_space? tyname tok_space? tok_comma tok_space? array_size tok_space? tok_rangle

array_size = n:tok_number {{
	value = n;
}} | tok_kw_null {{
	value = share(array_size {null_array_size {} });
}} | field_ref

# Literally just an alias for array<char, null>
tyname_string = tok_kw_string

tyname_rpc = tok_kw_rpc tok_space name:tok_ident {{ value = share(tyname_rpc {to_ptr<gsl::czstring<>>(name)}); }}

tyname_proj = tok_kw_projection tok_space name:tok_ident {{ 
	value = share(tyname_proj {to_ptr<gsl::czstring<>>(name)});
}}

tyname_any_of = tok_kw_any_of tok_space? tok_langle tok_space? field_ref tok_space? tok_comma tok_space? type_list tok_space? tok_rangle

type_list = tyname (tok_space? tok_comma tok_space? tyname)*

# These are types free of const or pointers
tyname_stem = tyname_array | tyname_string | tyname_rpc | tyname_proj | tyname_arith | tyname_any_of

indirection = (ptr_attrs tok_space?)? tok_star (tok_space? tok_kw_const)?

tyname = (tok_kw_const tok_space)? tyname_stem (tok_space? indirection)* (tok_space? val_attrs)?

rpc_def = tok_kw_rpc tok_space? tyname tok_space? tok_ident tok_space? tok_lpar (tok_space? argument_list)? tok_space? tok_rpar tok_space? tok_lbrace (tok_space? proj_def_list)? tok_space? tok_rbrace

proj_def_list = proj_def (tok_space? proj_def)*

argument_list = var_decl (tok_space? tok_comma tok_space? var_decl)*
