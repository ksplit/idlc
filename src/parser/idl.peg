start-symbol: file

include: {{
	#include <any>
	#include <memory>
	#include <type_traits>
	#include <iostream>

	#include <gsl/gsl>

	#include "string_heap.h"
	#include "ast.h"
	#include "parse_globals.h"
}}

code: {{
	using namespace idlc::parser;

	template<typename type>
	type to_int(const Value& v)
	{
		// FIXME: I know, precision bug
		static_assert(std::is_arithmetic_v<type> || std::is_enum_v<type>);
		return gsl::narrow<type>(reinterpret_cast<std::uintptr_t>(v.getValue()));
	}

	template<typename type>
	type to_ptr(const Value& v)
	{
		return static_cast<type>(const_cast<void*>(v.getValue()));
	}

	template<typename type>
	auto share(type&& v)
	{
		const auto ptr = std::make_shared<std::decay_t<type>>(v);
		parser_objs.emplace_back(ptr);
		return reinterpret_cast<const void*>(parser_objs.size() - 1);
	}

	template<typename type>
	std::shared_ptr<type> get_shared(const Value& v)
	{
		if (!v.getValue()) {
			return nullptr;
		}

		const auto id = to_int<std::size_t>(v);
		return std::any_cast<std::shared_ptr<type>>(gsl::at(parser_objs, id));
	}
}}

# Our design is simple: we keep a parser-global vector of shared_ptrs to every node we ever build, ensuring that cached
# nodes live long enough

rules:

# LEXING: These are the logical "tokens" of the language

tok_kw_const = "const"
tok_kw_void = "void"
tok_kw_string = "string"
tok_kw_projection = "projection"
tok_kw_rpc = "rpc"
tok_kw_rpc_ptr = "rpc_ptr"
tok_kw_driver = "driver"
tok_kw_module = "module"
tok_kw_header = "header"
tok_kw_import = "import"
tok_kw_struct = "struct"
tok_kw_union = "union"
tok_kw_char = "char"
tok_kw_bool = "bool"
tok_kw_short = "short"
tok_kw_int = "int"
tok_kw_long = "long"
tok_kw_signed = "signed"
tok_kw_unsigned = "unsigned"
tok_kw_void = "void"
tok_kw_include = "include"
tok_kw_array = "array"
tok_kw_null = "null"
tok_kw_this = "this"
tok_kw_in = "in"
tok_kw_out = "out"
tok_kw_alloc = "alloc"
tok_kw_dealloc = "dealloc"
tok_kw_bind = "bind"
tok_kw_caller = "caller"
tok_kw_callee = "callee"
tok_kw_any_of = "any_of"

tok_space = lex_blank+
tok_arrow = "->"
tok_langle = "<"
tok_rangle = ">"
tok_lbrace = "{"
tok_rbrace = "}"
tok_lbrack = "["
tok_rbrack = "]"
tok_lpar = "("
tok_rpar = ")"
tok_star = "*"
tok_semi = ";"
tok_comma = ","

tok_path = "<" chars:lex_path_char+ ">" {{
	std::string path {};
	for (const auto& c : chars.getValues())
		path += to_int<char>(c);

	value = idents.intern(path);
}}

tok_string = <ascii 34> chars:lex_string_char* <ascii 34> {{
	std::string path {};
	for (const auto& c : chars.getValues())
		path += to_int<char>(c);

	value = idents.intern(path);
}}

tok_number = digits:[0123456789]+ {{
	std::uint64_t n {};
	for (const auto& d : digits.getValues()) {
		n *= 10;
		n += to_int<char>(d) - '0';
	}

	value = reinterpret_cast<void*>(n);
}}

tok_ident = lex_ident_start rest:lex_ident_rest* {{
	std::string ident {};
	ident += to_int<char>($1);
	for (const auto& c : rest.getValues())
		ident += to_int<char>(c);

	value = idents.intern(ident);
}}

# TODO: clean this up
lex_path_char = [ !\"#$%&\'()*+,-./0123456789:;<=?@ABCDEFGHIJKLMNOPQRSTUVWXYZ[\\^_`abcdefghijklmnopqrstuvwxyz{|}~] | <ascii 93>
lex_string_char = [ !#$%&\'()*+,-./0123456789:;<=>?@ABCDEFGHIJKLMNOPQRSTUVWXYZ[\\^_`abcdefghijklmnopqrstuvwxyz{|}~] | <ascii 93>
lex_block_comment_char = [ !\"#$%&\'()*+,-./0123456789:;<=>?@ABCDEFGHIJKLMNOPQRSTUVWXYZ[\\^_`abcdefghijklmnopqrstuvwxyz{|}~] | lex_whitespace | <ascii 93>
lex_line_comment_char = [ !\"#$%&\'()*+,-./0123456789:;<=>?@ABCDEFGHIJKLMNOPQRSTUVWXYZ[\\^_`abcdefghijklmnopqrstuvwxyz{|}~] | [ \t] | <ascii 93>
lex_whitespace = [ \t\n\r]

lex_line_comment = "//" lex_line_comment_char* "\n"
lex_block_comment = "/*" lex_block_comment_char* "*/"
lex_comment = lex_line_comment | lex_block_comment
lex_blank = lex_whitespace+ | lex_comment

lex_ident_start = [_abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ]
lex_ident_rest = [01234567890] | lex_ident_start

# PARSER

# TODO: add "void" as allowable return type

file = dfile:driver_file {{
	value = share(file {get_shared<driver_file>(dfile)});
}} | mfile:module_file {{
	value = share(file {get_shared<std::vector<node_ref<module_def>>>(mfile)});
}}

driver_file = former:(tok_space? include_list)? tok_space? driver:driver_def latter:(tok_space? include_list)? tok_space? <eof> {{
	const auto former_ptr = get_shared<std::vector<gsl::czstring<>>>(former);
	const gsl::not_null driver_ptr {get_shared<driver_def>(driver)};
	const auto latter_ptr = get_shared<std::vector<gsl::czstring<>>>(latter);
	value = share(driver_file {former_ptr, driver_ptr, latter_ptr});
}}

include_list = first:include_stmt next:(tok_space? include_stmt)* {{
	const auto& next_vals = next.getValues();
	std::vector<gsl::czstring<>> paths {};
	paths.reserve(1 + next_vals.size());
	paths.emplace_back(to_ptr<gsl::czstring<>>(first));
	for (const auto& p : next_vals)
		paths.emplace_back(to_ptr<gsl::czstring<>>(p));

	value = share(std::move(paths));
}}

include_stmt = tok_kw_include tok_space? path:tok_path tok_space? tok_semi {{
	value = path;
}}

driver_def = tok_kw_driver tok_space name:tok_ident tok_space? tok_lbrace imports:(tok_space? import_list)? tok_space? tok_rbrace {{
	const auto name_val = to_ptr<gsl::czstring<>>(name);
	const auto imports_ptr = get_shared<std::vector<gsl::czstring<>>>(imports);
	value = share(driver_def {name_val, imports_ptr});
}}

import_list = first:import_stmt next:(tok_space? import_stmt)* {{
	const auto& next_vals = next.getValues();
	std::vector<gsl::czstring<>> idents {};
	idents.reserve(1 + next_vals.size());
	idents.emplace_back(to_ptr<gsl::czstring<>>(first));
	for (const auto& id : next_vals)
		idents.emplace_back(to_ptr<gsl::czstring<>>(id));

	value = share(std::move(idents));
}}

import_stmt = tok_kw_import tok_space ident:tok_ident tok_space? tok_semi {{ value = ident; }}

module_file = tok_space? list:module_list tok_space? <eof> {{
	value = list;
}}

module_list = first:module_def rest:(tok_space? module_def)* {{
	std::vector<node_ref<module_def>> list {};
	const auto& rvals = rest.getValues();
	list.reserve(rvals.size() + 1);
	list.emplace_back(get_shared<module_def>(first));
	for (const auto& item : rvals)
		list.emplace_back(get_shared<module_def>(item));

	value = share(std::move(list));
}}

module_def = tok_kw_module tok_space name:tok_ident tok_space? tok_lbrace items:(tok_space? module_item_list)? tok_space? tok_rbrace {{
	value = share(module_def {
		to_ptr<gsl::czstring<>>(name),
		get_shared<std::vector<node_ref<module_item>>>(items)
	});
}}

module_item_list = first:module_item rest:(tok_space? module_item)* {{
	std::vector<node_ref<module_item>> list {};
	const auto& rvals = rest.getValues();
	list.reserve(rvals.size() + 1);
	list.emplace_back(get_shared<module_item>(first));
	for (const auto& item : rvals)
		list.emplace_back(get_shared<module_item>(item));

	value = share(std::move(list));
}}

module_item = header_stmt {{
	value = share(module_item {header_stmt {} }); // TODO
}} | ud:union_proj_def {{
	value = share(module_item {get_shared<union_proj_def>(ud)});
}} | sd:struct_proj_def {{
	value = share(module_item {get_shared<struct_proj_def>(sd)});
}} | rpc:rpc_def {{
	value = share(module_item {get_shared<rpc_def>(rpc)});
}} | rpc_ptr:rpc_ptr_def {{
	value = share(module_item {get_shared<rpc_ptr_def>(rpc_ptr)});
}}

header_stmt = tok_kw_header tok_space? tok_path tok_space? tok_semi
	| tok_kw_header tok_space? tok_string tok_space? tok_semi

struct_proj_def = tok_kw_projection tok_space? tok_langle tok_space? tok_kw_struct tok_space? type:tok_ident tok_space? tok_rangle tok_space? name:tok_ident tok_space? tok_lbrace items:(tok_space? proj_field_list)? tok_space? tok_rbrace {{
	value = share(struct_proj_def {
		to_ptr<gsl::czstring<>>(name),
		to_ptr<gsl::czstring<>>(type),
		get_shared<std::vector<node_ref<proj_field>>>(items)
	});
}}

union_proj_def = tok_kw_projection tok_space? tok_langle tok_space? tok_kw_union tok_space? type:tok_ident tok_space? tok_rangle tok_space? name:tok_ident tok_space? tok_lbrace items:(tok_space? proj_field_list)? tok_space? tok_rbrace {{
	value = share(union_proj_def {
		to_ptr<gsl::czstring<>>(name),
		to_ptr<gsl::czstring<>>(type),
		get_shared<std::vector<node_ref<proj_field>>>(items)
	});
}}

field_ref = aref:field_abs_ref {{
	value = share(field_ref {get_shared<field_abs_ref>(aref)});
}} | rref:field_rel_ref {{
	value = share(field_ref {get_shared<field_rel_ref>(rref)});
}}

field_rel_ref = head:tok_ident rest:(tok_arrow tok_ident)* {{
	const auto rest_vals = rest.getValues();
	field_rel_ref ref {};
	ref.links.reserve(1 + rest_vals.size());
	ref.links.push_back(to_ptr<gsl::czstring<>>(head));
	for (const auto& val : rest_vals)
		ref.links.push_back(to_ptr<gsl::czstring<>>(val));

	value = share(std::move(ref));
}}

field_abs_ref = tok_kw_this tok_arrow link:field_rel_ref {{
	value = share(field_abs_ref {get_shared<field_rel_ref>(link)});
}}

proj_field_list = first:proj_field rest:(tok_space? proj_field)* {{
	std::vector<node_ref<proj_field>> list {};
	const auto& rest_vals = rest.getValues();
	list.reserve(1 + rest_vals.size());
	list.emplace_back(get_shared<proj_field>(first));
	for (const auto& item : rest_vals) {
		list.emplace_back(get_shared<proj_field>(item));
	}

	value = share(std::move(list));
}}

var_field = decl:var_decl tok_space? tok_semi {{ value = decl; }}

proj_field = vf:var_field {{
	value = share(proj_field {get_shared<var_decl>(vf)});
}} | npd:naked_proj_decl {{
	value = share(proj_field {get_shared<naked_proj_decl>(npd)});
}}

var_decl = ty:tyname tok_space? name:tok_ident {{
	value = share(var_decl {get_shared<tyname>(ty), to_ptr<gsl::czstring<>>(name)});
}}

naked_proj_decl = tok_kw_projection tok_space? tok_lbrace tok_space? fields:(proj_field_list tok_space?) tok_rbrace tok_space? name:tok_ident tok_space? tok_semi {{
	value = share(naked_proj_decl {
		get_shared<std::vector<node_ref<proj_field>>>(fields),
		to_ptr<gsl::czstring<>>(name)
	});
}}

val_attr = tok_kw_in {{ value = reinterpret_cast<void*>(tags::in); }}
	| tok_kw_out {{ value = reinterpret_cast<void*>(tags::out); }}

ptr_attr = tok_kw_in {{ value = reinterpret_cast<void*>(tags::in); }}
	| tok_kw_out {{ value = reinterpret_cast<void*>(tags::out); }}
	| tok_kw_alloc tok_space? tok_lpar tok_space? tok_kw_caller tok_space? tok_rpar {{
		value = reinterpret_cast<void*>(tags::alloc_caller);
	}}
	| tok_kw_alloc tok_space? tok_lpar tok_space? tok_kw_callee tok_space? tok_rpar {{
		value = reinterpret_cast<void*>(tags::alloc_callee);
	}}
	| tok_kw_dealloc tok_space? tok_lpar tok_space? tok_kw_caller tok_space? tok_rpar {{
		value = reinterpret_cast<void*>(tags::dealloc_caller);
	}}
	| tok_kw_dealloc tok_space? tok_lpar tok_space? tok_kw_callee tok_space? tok_rpar {{
		value = reinterpret_cast<void*>(tags::dealloc_callee);
	}}
	| tok_kw_bind tok_space? tok_lpar tok_space? tok_kw_caller tok_space? tok_rpar {{
		value = reinterpret_cast<void*>(tags::bind_caller);
	}}
	| tok_kw_bind tok_space? tok_lpar tok_space? tok_kw_callee tok_space? tok_rpar {{
		value = reinterpret_cast<void*>(tags::bind_callee);
	}}
	| tok_kw_alloc {{ value = reinterpret_cast<void*>(tags::is_alloc); }}
	| tok_kw_dealloc {{ value = reinterpret_cast<void*>(tags::is_dealloc); }}
	| tok_kw_bind {{ value = reinterpret_cast<void*>(tags::is_bind); }}

val_attrs = tok_lbrack tok_space? list:val_attr_list tok_space? tok_rbrack {{ value = list; }}

ptr_attrs = tok_lbrack tok_space? list:ptr_attr_list tok_space? tok_rbrack {{ value = list; }}

val_attr_list = first:val_attr rest:(tok_space? tok_comma tok_space? val_attr)* {{
	auto f = to_int<tags>(first);
	for (const auto r : rest.getValues()) {
		f |= to_int<tags>(r);
	}

	value = reinterpret_cast<void*>(f);
}}

ptr_attr_list = first:ptr_attr rest:(tok_space? tok_comma tok_space? ptr_attr)* {{
	auto f = to_int<tags>(first);
	for (const auto r : rest.getValues()) {
		f |= to_int<tags>(r);
	}

	value = reinterpret_cast<void*>(f);
}}

# HACK: we sort these alternates by length to get the parser to greedy-match them
# NOTE: we don't need type spacing rules for parsing since that parse will just fail in contexts where it's needed
# We'd only need if we were generating it, and even then we'd just pessimistically insert spaces anyways

tyname_arith = tok_kw_unsigned tok_space tok_kw_long tok_space tok_kw_long {{
	value = reinterpret_cast<void*>(tyname_arith::ty_ullong);
}} | tok_kw_unsigned tok_space tok_kw_long {{
	value = reinterpret_cast<void*>(tyname_arith::ty_ulong);
}} | tok_kw_long tok_space tok_kw_long {{
	value = reinterpret_cast<void*>(tyname_arith::ty_llong);
}} | tok_kw_unsigned tok_space tok_kw_int {{
	value = reinterpret_cast<void*>(tyname_arith::ty_uint);
}} | tok_kw_unsigned tok_space tok_kw_short {{
	value = reinterpret_cast<void*>(tyname_arith::ty_ushort);
}} | tok_kw_unsigned tok_space tok_kw_char {{
	value = reinterpret_cast<void*>(tyname_arith::ty_uchar);
}} | tok_kw_signed tok_space tok_kw_char {{
	value = reinterpret_cast<void*>(tyname_arith::ty_schar);
}} | tok_kw_short {{
	value = reinterpret_cast<void*>(tyname_arith::ty_short);
}} | tok_kw_int {{
	value = reinterpret_cast<void*>(tyname_arith::ty_int);
}} | tok_kw_long {{
	value = reinterpret_cast<void*>(tyname_arith::ty_long);
}} | tok_kw_char {{
	value = reinterpret_cast<void*>(tyname_arith::ty_char);
}} | tok_kw_bool {{
	value = reinterpret_cast<void*>(tyname_arith::ty_bool);
}}

# Do note that there is very little difference between const array<int, 10> and array<const int, 10>.
tyname_array = tok_kw_array tok_space? tok_langle tok_space? type:tyname tok_space? tok_comma tok_space? size:array_size tok_space? tok_rangle {{
	value = share(tyname_array {get_shared<tyname>(type), get_shared<array_size>(size)});
}}

array_size = n:tok_number {{
	value = share(array_size {to_int<unsigned>(n)});
}} | tok_kw_null {{
	value = share(array_size {tok_kw_null {} });
}} | ref:field_ref {{
	value = share(array_size {get_shared<field_ref>(ref)}); // TODO
}}

# Literally just an alias for array<char, null>
tyname_string = tok_kw_string

tyname_rpc = tok_kw_rpc_ptr tok_space name:tok_ident {{
	value = share(tyname_rpc {to_ptr<gsl::czstring<>>(name)});
}}

tyname_proj = tok_kw_projection tok_space name:tok_ident {{
	value = share(tyname_proj {to_ptr<gsl::czstring<>>(name)});
}}

tyname_any_of = tok_kw_any_of tok_space? tok_langle tok_space? ref:field_ref tok_space? tok_comma tok_space? types:type_list tok_space? tok_rangle {{
	value = share(tyname_any_of_ptr {get_shared<field_ref>(ref), get_shared<std::vector<node_ref<tyname>>>(types)});
}}

type_list = head:tyname rest:(tok_space? tok_comma tok_space? tyname)* {{
	const auto rvals = rest.getValues();
	std::vector<node_ref<tyname>> types {};
	types.reserve(rvals.size() + 1);
	types.push_back(get_shared<tyname>(head));
	for (const auto& type : rvals)
		types.push_back(get_shared<tyname>(type));

	value = share(std::move(types));
}}

# These are types free of const or pointers
tyname_stem = arr:tyname_array {{
	value = share(tyname_stem {get_shared<tyname_array>(arr)});
}} | str:tyname_string {{
	value = share(tyname_stem {tyname_string {} }); // yes, this is a tag
}} | rpc:tyname_rpc {{
	value = share(tyname_stem {get_shared<tyname_rpc>(rpc)});
}} | proj:tyname_proj {{
	value = share(tyname_stem {get_shared<tyname_proj>(proj)});
}} | arith:tyname_arith {{
	value = share(tyname_stem {to_int<tyname_arith>(arr)});
}} | any:tyname_any_of {{
	value = share(tyname_stem {get_shared<tyname_any_of_ptr>(any)});
}}

indirection = attrs:(ptr_attrs tok_space?)? tok_star is_c:(tok_space? tok_kw_const)? {{
	value = share(indirection {to_int<tags>(attrs), is_c.getValue()});
}}

# TODO: attributes
tyname = is_c:(tok_kw_const tok_space)? stem:tyname_stem indirs:(tok_space? indirection)* val_tags:(tok_space? val_attrs)? {{
	auto& ivals = indirs.getValues();
	std::vector<node_ref<indirection>> a {};
	a.reserve(ivals.size());
	for (const auto& indir : ivals)
		a.push_back(get_shared<indirection>(indir));

	value = share(tyname {is_c.getValue(), get_shared<tyname_stem>(stem), std::move(a), to_int<tags>(val_tags)});
}}

ret_type = tyname | tok_kw_void {{ // TODO: explicit? }}

rpc_def = tok_kw_rpc tok_space? ret_t:ret_type tok_space? name:tok_ident tok_space? tok_lpar args:(tok_space? argument_list)? tok_space? tok_rpar tok_space? tok_lbrace projs:(tok_space? rpc_item_list)? tok_space? tok_rbrace {{
	value = share(rpc_def {
		get_shared<tyname>(ret_t),
		to_ptr<gsl::czstring<>>(name),
		get_shared<std::vector<node_ref<var_decl>>>(args),
		get_shared<std::vector<node_ref<rpc_item>>>(projs)
	});
}}

rpc_ptr_def = tok_kw_rpc_ptr tok_space? ret_t:ret_type tok_space? name:tok_ident tok_space? tok_lpar args:(tok_space? argument_list)? tok_space? tok_rpar tok_space? tok_lbrace projs:(tok_space? rpc_item_list)? tok_space? tok_rbrace {{
	value = share(rpc_ptr_def {
		get_shared<tyname>(ret_t),
		to_ptr<gsl::czstring<>>(name),
		get_shared<std::vector<node_ref<var_decl>>>(args),
		get_shared<std::vector<node_ref<rpc_item>>>(projs)
	});
}}

rpc_item_list = first:rpc_item rest:(tok_space? rpc_item)* {{
	std::vector<node_ref<rpc_item>> list {};
	const auto& rvals = rest.getValues();
	list.reserve(rvals.size() + 1);
	list.emplace_back(get_shared<rpc_item>(first));
	for (const auto& item : rvals)
		list.emplace_back(get_shared<rpc_item>(item));

	value = share(std::move(list));
}}

rpc_item = ud:union_proj_def {{
	value = share(rpc_item {get_shared<union_proj_def>(ud)});
}} | sd:struct_proj_def {{
	value = share(rpc_item {get_shared<struct_proj_def>(sd)});
}}

argument_list = first:var_decl rest:(tok_space? tok_comma tok_space? var_decl)* {{
	std::vector<node_ref<var_decl>> list {};
	const auto& rvals = rest.getValues();
	list.reserve(rvals.size() + 1);
	list.emplace_back(get_shared<var_decl>(first));
	for (const auto& item : rvals)
		list.emplace_back(get_shared<var_decl>(item));

	value = share(std::move(list));
}}
