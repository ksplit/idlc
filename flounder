start-symbol: File
include: {{ #include "ast.h"
	    #include <vector>
	    #include <stdlib.h> }}
code: {{
      void cast_m(std::vector<Message* > * v, Value & val)
{
  for(Value::iterator it = val.getValues().begin(); it != val.getValues().end(); it++)
    {
      const Value & v2 = *it;
      Message* ms = (Message*) v2.getValue();
      v->push_back(ms);		     
    }
}
void cast_a(std::vector<Argument* > * v, Value & val)
{
  for(Value::iterator it = val.getValues().begin(); it != val.getValues().end(); it++)
    {
      const Value & v2 = *it;
      Argument* ms = (Argument*) v2.getValue();
      v->push_back(ms);		     
    }
}
}}
rules:
File	= Interface Spacing <eof> {{ value = $1; }}

Interface = INTERFACE n:Identifier OPENC m:Message+ CLOSEC SEMI {{ std::vector<Message*> * functions = new std::vector<Message*>;
		     cast_m(functions, m);
		     value = new Interface((char *)n.getValue(), functions); }}

		  | INTERFACE n:Identifier d:Description OPENC m:Message+ CLOSEC SEMI {{ std::vector<Message* > * functions = new std::vector<Message*>;
		     cast_m(functions, m);
		     value = new Interface((char *)n.getValue(),(char *)d.getValue(), functions); }}
		     

Message      =	   MESSAGE i:Identifier OPEN a:Arguments CLOSE SEMI Spacing {{ std::vector<Argument*> * args = new std::vector<Argument*>;
	     	   cast_a(args, a);
	     	   value = new Message((char*)i.getValue(), args); }}

Arguments    =	   a:ArgStart* {{ std::vector<Argument*> * args = new std::vector<Argument*>;
		      cast_a(args, a);
		      value = args; }}
		      
	     	   | a:ArgStart* a2:ArgLast {{ std::vector<Argument*> * args = new std::vector<Argument*>;
		      cast_a(args, a);
		      Argument * as = (Argument *) a2.getValue();
		      args->push_back(as);
		      value = args; }}

ArgStart     =	   s:SimpleArg COMMA {{ value = s; }}	        
		   | d:DynamicArg COMMA {{ value = d; }}

ArgLast	     =	   s:SimpleArg {{ value = s; }}
		   | d:DynamicArg {{ value = d; }}

SimpleArg    =	   t:Type i:Identifier {{ value = new Argument((Type*) t.getValue(), (char *) i.getValue()); }}

DynamicArg   =	   t:Type i:Identifier OPENS i2:Identifier CLOSES {{ value = new Argument((Type*) t.getValue(), (char *) i.getValue(), (char *) i2.getValue()); }}

#Types	     =	   #incomplete
Type	     =	   "bool" | "int32" | "char"
	     	   

Description  =	   """ d:.* """ Spacing
	     	   

Identifier   =	   i1:IdentStart i2:IdentCont* Spacing {{ char * f = (char *) malloc(2*sizeof(char));
	     	   		 f[0] = (char) (intptr_t) i1.getValue();
				 f[1] = '\0';
		      char * str = (char *) malloc(sizeof(char)+1+(sizeof(char)*i2.getValues().size()));
		      strcpy(str, f);
		      for(Value::iterator it = i2.getValues().begin(); it != i2.getValues().end(); it ++)
		      {
			const Value & v = *it;
			char * temp = (char *) malloc(2*sizeof(char));
			char ms = (char) (intptr_t) v.getValue();
			temp[0] = ms;
			temp[1] = '\0';
			strcat(str, temp);
		     }
		     value = str; }}
		      
IdentStart   =	   i:[a-zA-Z_] {{
		      value = i; }}
IdentCont    =	   i:IdentStart {{
		      value = i; }}
		   | i:[0-9] {{ 
		      value = i; }}



## reserved words
MESSAGE	     =	   "message" Spacing
INTERFACE    =	   "interface" Spacing


SEMI	     =	   ";"
OPENC	     =	   "{"
CLOSEC	     =	   "}"
OPENS	     =	   "["
CLOSES	     =	   "]"
OPEN	     =	   "("
CLOSE	     =	   ")"
COMMA	     =	   ","

Spacing	     =	   Space*
Space	     =	   " " | "\t" | EndOfLine
Comment	     =	   "/*" .* "*/" 
	     	   | "//" (!EndOfLine .)* EndOfLine

EndOfLine    =	   "\r\n" | "\n" | "\r"
