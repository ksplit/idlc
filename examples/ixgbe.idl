module kernel {
rpc void usleep_range( u64 min, u64 max ) {
}
rpc bool cancel_work_sync( projection work * work ) {
	projection < struct work_struct > work {
	}
}
rpc u64 msleep_interruptible( u32 msecs ) {
}
rpc u64 timecounter_cyc2time( projection tc * tc, u64 cycle_tstamp ) {
	projection < struct timecounter > tc {
		u64  nsec;
	}
}
rpc u64 timecounter_read( projection tc * tc ) {
	projection < struct timecounter > tc {
		u64 [out] nsec;
	}
}
rpc void timecounter_init( projection tc * tc, projection cc * cc, u64 start_tstamp ) {
	projection < struct timecounter > tc {
		u64 [out] nsec;
	}
	projection < struct cyclecounter > cc {
		rpc_ptr read read;
		u32  shift;
	}
}
rpc_ptr u32 probe( projection pdev * pdev, projection ent * ent ) {
	projection < struct pci_dev > pdev {
		u16  vendor;
		u16  device;
		u16  subsystem_device;
		//array< struct resource, 11>  resource;
		u32  transparent;
	}
	projection < struct pci_device_id > ent {
		u64  driver_data;
	}
}
rpc_ptr void remove( projection pdev * pdev ) {
	projection < struct pci_dev > pdev {
	}
}
rpc_ptr void shutdown( projection pdev * pdev ) {
	projection < struct pci_dev > pdev {
	}
}
rpc_ptr u32 sriov_configure( projection dev * dev, u32 num_vfs ) {
	projection < struct pci_dev > dev {
	}
}
rpc_ptr u32 error_detected( projection pdev * pdev, u32 state ) {
	projection < struct pci_dev > pdev {
	}
}
rpc_ptr u32 slot_reset( projection pdev * pdev ) {
	projection < struct pci_dev > pdev {
	}
}
rpc_ptr void resume( projection pdev * pdev ) {
	projection < struct pci_dev > pdev {
	}
}
rpc_ptr void ndo_set_rx_mode( projection netdev * netdev ) {
	projection < struct net_device > netdev {
		u64  features;
		u32  flags;
	}
}
rpc_ptr u32 ndo_vlan_rx_add_vid( projection netdev * netdev, u16 proto, u16 vid ) {
	projection < struct net_device > netdev {
	}
}
rpc_ptr u32 ndo_set_vf_spoofchk( projection netdev * netdev, u32 vf, bool setting ) {
	projection < struct net_device > netdev {
	}
}
rpc_ptr u32 ndo_set_vf_rss_query_en( projection netdev * netdev, u32 vf, bool setting ) {
	projection < struct net_device > netdev {
	}
}
rpc_ptr u32 read( projection filp * filp, u8* buffer, u64 count, u64* ppos ) {
	projection < struct file > filp {
		//void*  private_data;
	}
}
rpc_ptr u32 write( projection filp * filp, u8* buffer, u64 count, u64* ppos ) {
	projection < struct file > filp {
		//void*  private_data;
	}
}
rpc u32 ixgbe_dbg_reg_ops_read( projection filp * filp, u8* buffer, u64 count, u64* ppos ) {
	projection < struct file > filp {
		//void*  private_data;
	}
}
rpc u32 ixgbe_dbg_reg_ops_write( projection filp * filp, u8* buffer, u64 count, u64* ppos ) {
	projection < struct file > filp {
		//void*  private_data;
	}
}
rpc u32 ixgbe_init_eeprom_params_generic( projection hw * hw ) {
	projection < struct ixgbe_hw > hw {
	}
}
rpc_ptr u32 get_settings( projection netdev * netdev, projection ecmd * ecmd ) {
	projection < struct net_device > netdev {
	}
	projection < struct ethtool_cmd > ecmd {
		u32 [out] supported;
		u32 [out] advertising;
		u8 [out] duplex;
		u8 [out] port;
		u8 [out] transceiver;
		u8 [out] autoneg;
	}
}
rpc_ptr u32 set_settings( projection netdev * netdev, projection ecmd * ecmd ) {
	projection < struct net_device > netdev {
	}
	projection < struct ethtool_cmd > ecmd {
		u32  supported;
		u32  advertising;
		u8  duplex;
		u8  autoneg;
	}
}
rpc_ptr void get_drvinfo( projection netdev * netdev, projection drvinfo * drvinfo ) {
	projection < struct net_device > netdev {
	}
	projection < struct ethtool_drvinfo > drvinfo {
	}
}
rpc_ptr u32 get_regs_len( projection netdev * netdev ) {
	projection < struct net_device > netdev {
	}
}
rpc_ptr void get_regs( projection netdev * netdev, projection regs * regs){ //, void* p ) {
	projection < struct net_device > netdev {
	}
	projection < struct ethtool_regs > regs {
	}
}
rpc_ptr void get_wol( projection netdev * netdev, projection wol * wol ) {
	projection < struct net_device > netdev {
	}
	projection < struct ethtool_wolinfo > wol {
	}
}
rpc_ptr u32 set_wol( projection netdev * netdev, projection wol * wol ) {
	projection < struct net_device > netdev {
	}
	projection < struct ethtool_wolinfo > wol {
	}
}
rpc_ptr u32 get_msglevel( projection netdev * netdev ) {
	projection < struct net_device > netdev {
	}
}
rpc_ptr void set_msglevel( projection netdev * netdev, u32 data ) {
	projection < struct net_device > netdev {
	}
}
rpc_ptr u32 nway_reset( projection netdev * netdev ) {
	projection < struct net_device > netdev {
	}
}
rpc_ptr u32 get_eeprom_len( projection netdev * netdev ) {
	projection < struct net_device > netdev {
	}
}
rpc_ptr u32 get_eeprom( projection netdev * netdev, projection eeprom * eeprom, u8* bytes ) {
	projection < struct net_device > netdev {
	}
	projection < struct ethtool_eeprom > eeprom {
	}
}
rpc_ptr u32 set_eeprom( projection netdev * netdev, projection eeprom * eeprom, u8* bytes ) {
	projection < struct net_device > netdev {
	}
	projection < struct ethtool_eeprom > eeprom {
	}
}
rpc_ptr u32 get_coalesce( projection netdev * netdev, projection ec * ec ) {
	projection < struct net_device > netdev {
	}
	projection < struct ethtool_coalesce > ec {
	}
}
rpc_ptr u32 set_coalesce( projection netdev * netdev, projection ec * ec ) {
	projection < struct net_device > netdev {
	}
	projection < struct ethtool_coalesce > ec {
	}
}
rpc_ptr void get_ringparam( projection netdev * netdev, projection ring * ring ) {
	projection < struct net_device > netdev {
	}
	projection < struct ethtool_ringparam > ring {
	}
}
rpc_ptr u32 set_ringparam( projection netdev * netdev, projection ring * ring ) {
	projection < struct net_device > netdev {
	}
	projection < struct ethtool_ringparam > ring {
	}
}
rpc_ptr void get_pauseparam( projection netdev * netdev, projection pause * pause ) {
	projection < struct net_device > netdev {
	}
	projection < struct ethtool_pauseparam > pause {
	}
}
rpc_ptr u32 set_pauseparam( projection netdev * netdev, projection pause * pause ) {
	projection < struct net_device > netdev {
	}
	projection < struct ethtool_pauseparam > pause {
	}
}
rpc_ptr void self_test( projection netdev * netdev, projection eth_test * eth_test, u64* data ) {
	projection < struct net_device > netdev {
	}
	projection < struct ethtool_test > eth_test {
	}
}
rpc_ptr void get_strings( projection netdev * netdev, u32 stringset, u8* data ) {
	projection < struct net_device > netdev {
		u32  num_tx_queues;
	}
}
rpc_ptr u32 set_phys_id( projection netdev * netdev, u32 state ) {
	projection < struct net_device > netdev {
	}
}
rpc_ptr void get_ethtool_stats( projection netdev * netdev, projection stats * stats, u64* data ) {
	projection < struct net_device > netdev {
		u32  num_tx_queues;
	}
	projection < struct ethtool_stats > stats {
	}
}
rpc_ptr u32 get_sset_count( projection netdev * netdev, u32 sset ) {
	projection < struct net_device > netdev {
		u32  num_tx_queues;
	}
}
rpc_ptr u32 get_rxnfc( projection dev * dev, projection cmd * cmd, u32* rule_locs ) {
	projection < struct net_device > dev {
	}
	projection < struct ethtool_rxnfc > cmd {
	}
}
rpc_ptr u32 set_rxnfc( projection dev * dev, projection cmd * cmd ) {
	projection < struct net_device > dev {
	}
	projection < struct ethtool_rxnfc > cmd {
	}
}
rpc_ptr u32 get_rxfh_key_size( projection netdev * netdev ) {
	projection < struct net_device > netdev {
	}
}
rpc_ptr u32 get_rxfh_indir_size( projection netdev * netdev ) {
	projection < struct net_device > netdev {
	}
}
rpc_ptr u32 get_rxfh( projection netdev * netdev, u32* indir, u8* key, u8* hfunc ) {
	projection < struct net_device > netdev {
	}
}
rpc_ptr u32 set_rxfh( projection netdev * netdev, u32* indir, u8* key, u8 hfunc ) {
	projection < struct net_device > netdev {
	}
}
rpc_ptr void get_channels( projection dev * dev, projection ch * ch ) {
	projection < struct net_device > dev {
	}
	projection < struct ethtool_channels > ch {
	}
}
rpc_ptr u32 set_channels( projection dev * dev, projection ch * ch ) {
	projection < struct net_device > dev {
	}
	projection < struct ethtool_channels > ch {
	}
}
rpc_ptr u32 get_ts_info( projection dev * dev, projection info * info ) {
	projection < struct net_device > dev {
	}
	projection < struct ethtool_ts_info > info {
		u32 [out] so_timestamping;
		u32 [out] phc_index;
	}
}
rpc_ptr u32 get_module_info( projection dev * dev, projection modinfo * modinfo ) {
	projection < struct net_device > dev {
	}
	projection < struct ethtool_modinfo > modinfo {
	}
}
rpc_ptr u32 get_module_eeprom( projection dev * dev, projection ee * ee, u8* data ) {
	projection < struct net_device > dev {
	}
	projection < struct ethtool_eeprom > ee {
	}
}
rpc_ptr u32 ndo_stop( projection netdev * netdev ) {
	projection < struct net_device > netdev {
	}
}
rpc_ptr u32 ndo_open( projection netdev * netdev ) {
	projection < struct net_device > netdev {
	}
}
rpc_ptr u32 ndo_start_xmit( projection skb * skb, projection netdev * netdev ) {
	projection < struct sk_buff > skb {
	}
	projection < struct net_device > netdev {
	}
}
rpc_ptr u64 ndo_features_check( projection skb * skb, projection dev * dev, u64 features ) {
	projection < struct sk_buff > skb {
		//array  headers_start;
		//array  __pkt_type_offset;
		u8  pkt_type;
		u8*  data;
	}
	projection < struct net_device > dev {
	}
}
rpc_ptr u16 ndo_select_queue( projection dev * dev, projection skb * skb) {//, void* accel_priv, * fallback ) {
	projection < struct net_device > dev {
	}
	projection < struct sk_buff > skb {
		u16  queue_mapping;
	}
}
rpc_ptr u32 ndo_set_mac_address( projection netdev * netdev) {//, void* p ) {
	projection < struct net_device > netdev {
		u8  addr_len;
		u8*  dev_addr;
	}
}
rpc_ptr u32 ndo_do_ioctl( projection netdev * netdev, projection req * req, u32 cmd ) {
	projection < struct net_device > netdev {
	}
	projection < struct ifreq > req {
	}
}
rpc_ptr u32 ndo_change_mtu( projection netdev * netdev, u32 new_mtu ) {
	projection < struct net_device > netdev {
		u32 [out] mtu;
	}
}
rpc_ptr void ndo_tx_timeout( projection netdev * netdev ) {
	projection < struct net_device > netdev {
	}
}
rpc_ptr projection ret_rtnl_link_stats64* ndo_get_stats64( projection netdev * netdev, projection stats * stats ) {
	projection < struct rtnl_link_stats64 >  ret_rtnl_link_stats64{
		u64 [out] rx_packets;
		u64 [out] tx_packets;
		u64 [out] rx_bytes;
		u64 [out] tx_bytes;
		u64 [out] rx_errors;
		u64 [out] multicast;
		u64 [out] rx_length_errors;
		u64 [out] rx_crc_errors;
		u64 [out] rx_missed_errors;
	}
	projection < struct net_device > netdev {
		/*projection  {
		} stats;*/
	}
	projection < struct rtnl_link_stats64 > stats {
		u64 [out] rx_packets;
		u64 [out] tx_packets;
		u64 [out] rx_bytes;
		u64 [out] tx_bytes;
		u64 [out] rx_errors;
		u64 [out] multicast;
		u64 [out] rx_length_errors;
		u64 [out] rx_crc_errors;
		u64 [out] rx_missed_errors;
	}
}
rpc_ptr u32 ndo_vlan_rx_kill_vid( projection netdev * netdev, u16 proto, u16 vid ) {
	projection < struct net_device > netdev {
	}
}
rpc_ptr u32 ndo_busy_poll( projection napi * napi ) {
	projection < struct napi_struct > napi {
	}
}
rpc_ptr u32 ndo_set_vf_mac( projection netdev * netdev, u32 vf, u8* mac ) {
	projection < struct net_device > netdev {
	}
}
rpc_ptr u32 ndo_set_vf_vlan( projection netdev * netdev, u32 vf, u16 vlan, u8 qos ) {
	projection < struct net_device > netdev {
	}
}
rpc_ptr u32 ndo_set_vf_rate( projection netdev * netdev, u32 vf, u32 min_tx_rate, u32 max_tx_rate ) {
	projection < struct net_device > netdev {
	}
}
rpc_ptr u32 ndo_set_vf_trust( projection netdev * netdev, u32 vf, bool setting ) {
	projection < struct net_device > netdev {
	}
}
rpc_ptr u32 ndo_get_vf_config( projection netdev * netdev, u32 vf, projection ivi * ivi ) {
	projection < struct net_device > netdev {
	}
	projection < struct ifla_vf_info > ivi {
		u32 [out] vf;
		u32 [out] vlan;
		u32 [out] qos;
		u32 [out] spoofchk;
		u32 [out] min_tx_rate;
		u32 [out] max_tx_rate;
		u32 [out] rss_query_en;
		u32 [out] trusted;
	}
}
rpc_ptr u32 ndo_setup_tc( projection dev * dev, u32 handle, u16 proto, projection tc * tc ) {
	projection < struct net_device > dev {
	}
	projection < struct tc_to_netdev > tc {
	}
}
rpc_ptr u64 ndo_fix_features( projection netdev * netdev, u64 features ) {
	projection < struct net_device > netdev {
	}
}
rpc_ptr u32 ndo_set_features( projection netdev * netdev, u64 features ) {
	projection < struct net_device > netdev {
		u64 [out] features;
	}
}
rpc_ptr u32 ndo_fdb_add( projection ndm * ndm, projection tb * tb, projection dev * dev, u8* addr, u16 vid, u16 flags ) {
	projection < struct ndmsg > ndm {
	}
	projection < struct nlattr > tb {
	}
	projection < struct net_device > dev {
		/*projection  {
			u32  count;
		} uc;*/
	}
}
rpc_ptr u32 ndo_bridge_setlink( projection dev * dev, projection nlh * nlh, u16 flags ) {
	projection < struct net_device > dev {
	}
	projection < struct nlmsghdr > nlh {
	}
}
rpc_ptr u32 ndo_bridge_getlink( projection skb * skb, u32 pid, u32 seq, projection dev * dev, u32 filter_mask, u32 nlflags ) {
	projection < struct sk_buff > skb {
	}
	projection < struct net_device > dev {
	}
}
rpc_ptr void ndo_udp_tunnel_add( projection dev * dev, projection ti * ti ) {
	projection < struct net_device > dev {
	}
	projection < struct udp_tunnel_info > ti {
	}
}
rpc_ptr void ndo_udp_tunnel_del( projection dev * dev, projection ti * ti ) {
	projection < struct net_device > dev {
	}
	projection < struct udp_tunnel_info > ti {
	}
}
rpc_ptr void ndo_dfwd_add_station( projection pdev * pdev, projection vdev * vdev ) {
	projection < struct net_device > pdev {
		array< u8, 16>  name;
	}
	projection < struct net_device > vdev {
		array< u8, 16>  name;
		u32  num_rx_queues;
		u32  num_tx_queues;
	}
}
rpc_ptr void ndo_dfwd_del_station( projection pdev * pdev, void* priv ) {
	projection < struct net_device > pdev {
	}
}
rpc_ptr u32 ndo_set_tx_maxrate( projection netdev * netdev, u32 queue_index, u32 maxrate ) {
	projection < struct net_device > netdev {
	}
}
rpc_ptr u32 get_invariants( projection hw * hw ) {
	projection < struct ixgbe_hw > hw {
	}
}
rpc u32 ixgbe_read_mbx_pf( projection hw * hw, u32* msg, u16 size, u16 vf_number ) {
	projection < struct ixgbe_hw > hw {
	}
}
rpc u32 ixgbe_write_mbx_pf( projection hw * hw, u32* msg, u16 size, u16 vf_number ) {
	projection < struct ixgbe_hw > hw {
	}
}
rpc_ptr u32 read_posted( projection hw * hw, u32* msg, u16 size, u16 mbx_id ) {
	projection < struct ixgbe_hw > hw {
	}
}
rpc_ptr u32 write_posted( projection hw * hw, u32* msg, u16 size, u16 mbx_id ) {
	projection < struct ixgbe_hw > hw {
	}
}
rpc_ptr u32 check_for_msg( projection hw * hw, u16 vf_number ) {
	projection < struct ixgbe_hw > hw {
	}
}
rpc_ptr u32 check_for_ack( projection hw * hw, u16 vf_number ) {
	projection < struct ixgbe_hw > hw {
	}
}
rpc_ptr u32 check_for_rst( projection hw * hw, u16 vf_number ) {
	projection < struct ixgbe_hw > hw {
		/* projection  {
		} mac; */
	}
}
rpc_ptr u32 identify( projection hw * hw ) {
	projection < struct ixgbe_hw > hw {
	}
}
rpc_ptr u32 init( projection hw * hw ) {
	projection < struct ixgbe_hw > hw {
		/* projection  {
		} mac; */
	}
}
rpc_ptr u32 read_reg( projection hw * hw, u32 reg_addr, u32 device_type, u16* phy_data ) {
	projection < struct ixgbe_hw > hw {
		/* projection  {
		} mac; */
	}
}
rpc_ptr u32 write_reg( projection hw * hw, u32 reg_addr, u32 device_type, u16 phy_data ) {
	projection < struct ixgbe_hw > hw {
		/* projection  {
		} mac; */
	}
}
rpc u32 ixgbe_read_iosf_sb_reg_x550( projection hw * hw, u32 reg_addr, u32 device_type, u32* data ) {
	projection < struct ixgbe_hw > hw {
		/* projection  {
		} mac; */
	}
}
rpc u32 ixgbe_write_iosf_sb_reg_x550( projection hw * hw, u32 reg_addr, u32 device_type, u32 data ) {
	projection < struct ixgbe_hw > hw {
		/* projection  {
		} mac; */
	}
}
rpc_ptr u32 setup_fc( projection hw * hw ) {
	projection < struct ixgbe_hw > hw {
		/* projection  {
		} mac; */
	}
}
rpc u32 ixgbe_setup_fc_generic( projection hw * hw ) {
	projection < struct ixgbe_hw > hw {
		/* projection  {
		} mac; */
	}
}
rpc u32 ixgbe_check_mac_link_generic( projection hw * hw, u32* speed, bool* link_up, bool link_up_wait_to_complete ) {
	projection < struct ixgbe_hw > hw {
		/* projection  {
		} mac; */
	}
}
rpc u32 ixgbe_init_eeprom_params_X540( projection hw * hw ) {
	projection < struct ixgbe_hw > hw {
	}
}
rpc u32 ixgbe_read_ee_hostif_X550( projection hw * hw, u16 offset, u16* data ) {
	projection < struct ixgbe_hw > hw {
		/* projection  {
		} mac; */
	}
}
rpc_ptr u32 read_buffer( projection hw * hw, u16 offset, u16 words, u16* data ) {
	projection < struct ixgbe_hw > hw {
		/* projection  {
		} mac; */
	}
}
rpc u32 ixgbe_write_ee_hostif_X550( projection hw * hw, u16 offset, u16 data ) {
	projection < struct ixgbe_hw > hw {
		/* projection  {
		} mac; */
	}
}
rpc_ptr u32 write_buffer( projection hw * hw, u16 offset, u16 words, u16* data ) {
	projection < struct ixgbe_hw > hw {
		/* projection  {
		} mac; */
	}
}
rpc_ptr u32 validate_checksum( projection hw * hw, u16* checksum_val ) {
	projection < struct ixgbe_hw > hw {
	}
}
rpc_ptr u32 update_checksum( projection hw * hw ) {
	projection < struct ixgbe_hw > hw {
	}
}
rpc_ptr u32 calc_checksum( projection hw * hw ) {
	projection < struct ixgbe_hw > hw {
	}
}
rpc_ptr u32 init_hw( projection hw * hw ) {
	projection < struct ixgbe_hw > hw {
		/* projection  {
		} mac; */
	}
}
rpc_ptr u32 reset_hw( projection hw * hw ) {
	projection < struct ixgbe_hw > hw {
		/* projection  {
		} mac; */
	}
}
rpc_ptr u32 start_hw( projection hw * hw ) {
	projection < struct ixgbe_hw > hw {
	}
}
rpc_ptr u32 clear_hw_cntrs( projection hw * hw ) {
	projection < struct ixgbe_hw > hw {
		/* projection  {
		} mac; */
	}
}
rpc_ptr u32 get_media_type( projection hw * hw ) {
	projection < struct ixgbe_hw > hw {
	}
}
rpc_ptr u32 get_mac_addr( projection hw * hw, u8* mac_addr ) {
	projection < struct ixgbe_hw > hw {
	}
}
rpc_ptr u32 get_device_caps( projection hw * hw, u16* device_caps ) {
	projection < struct ixgbe_hw > hw {
	}
}
rpc_ptr u32 stop_adapter( projection hw * hw ) {
	projection < struct ixgbe_hw > hw {
		/* projection  {
		} mac; */
	}
}
rpc_ptr u32 get_bus_info( projection hw * hw ) {
	projection < struct ixgbe_hw > hw {
		/* projection  {
		} mac; */
	}
}
rpc void ixgbe_set_lan_id_multi_port_pcie( projection hw * hw ) {
	projection < struct ixgbe_hw > hw {
	}
}
rpc_ptr u32 setup_sfp( projection hw * hw ) {
	projection < struct ixgbe_hw > hw {
	}
}
rpc_ptr u32 disable_rx_buff( projection hw * hw ) {
	projection < struct ixgbe_hw > hw {
	}
}
rpc_ptr u32 enable_rx_buff( projection hw * hw ) {
	projection < struct ixgbe_hw > hw {
	}
}
rpc_ptr u32 acquire_swfw_sync( projection hw * hw, u32 mask ) {
	projection < struct ixgbe_hw > hw {
	}
}
rpc_ptr void release_swfw_sync( projection hw * hw, u32 mask ) {
	projection < struct ixgbe_hw > hw {
	}
}
rpc_ptr u32 get_link_capabilities( projection hw * hw, u32* speed, bool* autoneg ) {
	projection < struct ixgbe_hw > hw {
	}
}
rpc void ixgbe_set_rxpba_generic( projection hw * hw, u32 num_pb, u32 headroom, u32 strategy ) {
	projection < struct ixgbe_hw > hw {
		/* projection  {
		} mac; */
	}
}
rpc_ptr u32 led_on( projection hw * hw, u32 index ) {
	projection < struct ixgbe_hw > hw {
	}
}
rpc_ptr u32 led_off( projection hw * hw, u32 index ) {
	projection < struct ixgbe_hw > hw {
	}
}
rpc_ptr u32 blink_led_start( projection hw * hw, u32 index ) {
	projection < struct ixgbe_hw > hw {
		/* projection  {
		} mac; */
	}
}
rpc_ptr u32 blink_led_stop( projection hw * hw, u32 index ) {
	projection < struct ixgbe_hw > hw {
	}
}
rpc_ptr u32 set_rar( projection hw * hw, u32 index, u8* addr, u32 vmdq, u32 enable_addr ) {
	projection < struct ixgbe_hw > hw {
		/* projection  {
		} mac; */
	}
}
rpc_ptr u32 clear_rar( projection hw * hw, u32 index ) {
	projection < struct ixgbe_hw > hw {
		/* projection  {
		} mac; */
	}
}
rpc u32 ixgbe_set_vmdq_generic( projection hw * hw, u32 rar, u32 vmdq ) {
	projection < struct ixgbe_hw > hw {
		/* projection  {
		} mac; */
	}
}
rpc_ptr u32 set_vmdq_san_mac( projection hw * hw, u32 vmdq ) {
	projection < struct ixgbe_hw > hw {
		/* projection  {
		} mac; */
	}
}
rpc u32 ixgbe_clear_vmdq_generic( projection hw * hw, u32 rar, u32 vmdq ) {
	projection < struct ixgbe_hw > hw {
		u8*  hw_addr;
		/* projection  {
		} mac; */
	}
}
rpc_ptr u32 init_rx_addrs( projection hw * hw ) {
	projection < struct ixgbe_hw > hw {
		/* projection  {
		} mac; */
	}
}
rpc_ptr u32 update_mc_addr_list( projection hw * hw, projection netdev * netdev ) {
	projection < struct ixgbe_hw > hw {
		/* projection  {
		} mac; */
	}
	projection < struct net_device > netdev {
		/*projection  {
			projection  {
				projection struct list_head* next;
			} list;
			u32  count;
		} mc;*/
	}
	projection < struct list_head > next {
	}
}
rpc_ptr u32 enable_mc( projection hw * hw ) {
	projection < struct ixgbe_hw > hw {
		/* projection  {
		} mac; */
	}
}
rpc_ptr u32 disable_mc( projection hw * hw ) {
	projection < struct ixgbe_hw > hw {
		/* projection  {
		} mac; */
	}
}
rpc u32 ixgbe_clear_vfta_generic( projection hw * hw ) {
	projection < struct ixgbe_hw > hw {
		/* projection  {
		} mac; */
	}
}
rpc u32 ixgbe_set_vfta_generic( projection hw * hw, u32 vlan, u32 vind, bool vlan_on, bool vlvf_bypass ) {
	projection < struct ixgbe_hw > hw {
	}
}
rpc_ptr u32 init_uta_tables( projection hw * hw ) {
	projection < struct ixgbe_hw > hw {
	}
}
rpc_ptr void set_mac_anti_spoofing( projection hw * hw, bool enable, u32 vf ) {
	projection < struct ixgbe_hw > hw {
		/* projection  {
		} mac; */
	}
}
rpc_ptr void set_vlan_anti_spoofing( projection hw * hw, bool enable, u32 vf ) {
	projection < struct ixgbe_hw > hw {
		/* projection  {
		} mac; */
	}
}
rpc u32 ixgbe_fc_enable_generic( projection hw * hw ) {
	projection < struct ixgbe_hw > hw {
	}
}
rpc_ptr u32 set_fw_drv_ver( projection hw * hw, u8 maj, u8 min, u8 build, u8 sub ) {
	projection < struct ixgbe_hw > hw {
	}
}
rpc_ptr void disable_rx( projection hw * hw ) {
	projection < struct ixgbe_hw > hw {
		/* projection  {
		} mac; */
	}
}
rpc_ptr void enable_rx( projection hw * hw ) {
	projection < struct ixgbe_hw > hw {
		/* projection  {
		} mac; */
	}
}
rpc_ptr void set_source_address_pruning( projection hw * hw, bool enable, u32 pool ) {
	projection < struct ixgbe_hw > hw {
	}
}
rpc_ptr void set_ethertype_anti_spoofing( projection hw * hw, bool enable, u32 vf ) {
	projection < struct ixgbe_hw > hw {
	}
}
rpc_ptr u32 read_iosf_sb_reg( projection hw * hw, u32 reg_addr, u32 device_type, u32* data ) {
	projection < struct ixgbe_hw > hw {
	}
}
rpc_ptr u32 write_iosf_sb_reg( projection hw * hw, u32 reg_addr, u32 device_type, u32 data ) {
	projection < struct ixgbe_hw > hw {
	}
}
rpc void ixgbe_release_swfw_sync_X540( projection hw * hw, u32 mask ) {
	projection < struct ixgbe_hw > hw {
	}
}
rpc u32 ixgbe_acquire_swfw_sync_X540( projection hw * hw, u32 mask ) {
	projection < struct ixgbe_hw > hw {
	}
}
rpc u32 ixgbe_get_invariants_X540( projection hw * hw ) {
	projection < struct ixgbe_hw > hw {
	}
}
rpc u32 ixgbe_acquire_swfw_sync_X550em( projection hw * hw, u32 mask ) {
	projection < struct ixgbe_hw > hw {
	}
}
rpc void ixgbe_release_swfw_sync_X550em( projection hw * hw, u32 mask ) {
	projection < struct ixgbe_hw > hw {
	}
}
rpc_ptr void init_swfw_sync( projection hw * hw ) {
	projection < struct ixgbe_hw > hw {
	}
}
rpc_ptr u32 setup_link( projection hw * hw, u32 speed, bool autoneg_wait_to_complete ) {
	projection < struct ixgbe_hw > hw {
	}
}
rpc_ptr u32 init_params( projection hw * hw ) {
	projection < struct ixgbe_hw > hw {
	}
}
rpc u32 ixgbe_reset_hw_X540( projection hw * hw ) {
	projection < struct ixgbe_hw > hw {
		/* projection  {
		} mac; */
	}
}
rpc u32 ixgbe_get_media_type_X540( projection hw * hw ) {
	projection < struct ixgbe_hw > hw {
	}
}
rpc_ptr u32 get_san_mac_addr( projection hw * hw, u8* san_mac_addr ) {
	projection < struct ixgbe_hw > hw {
		/* projection  {
		} mac; */
	}
}
rpc_ptr u32 get_wwn_prefix( projection hw * hw, u16* wwnn_prefix, u16* wwpn_prefix ) {
	projection < struct ixgbe_hw > hw {
	}
}
rpc u32 ixgbe_get_bus_info_generic( projection hw * hw ) {
	projection < struct ixgbe_hw > hw {
		/* projection  {
		} mac; */
	}
}
rpc u32 ixgbe_read_eerd_X540( projection hw * hw, u16 offset, u16* data ) {
	projection < struct ixgbe_hw > hw {
		/* projection  {
		} mac; */
	}
}
rpc u32 ixgbe_read_eerd_buffer_X540( projection hw * hw, u16 offset, u16 words, u16* data ) {
	projection < struct ixgbe_hw > hw {
		/* projection  {
		} mac; */
	}
}
rpc u32 ixgbe_write_eewr_X540( projection hw * hw, u16 offset, u16 data ) {
	projection < struct ixgbe_hw > hw {
		/* projection  {
		} mac; */
	}
}
rpc u32 ixgbe_write_eewr_buffer_X540( projection hw * hw, u16 offset, u16 words, u16* data ) {
	projection < struct ixgbe_hw > hw {
		/* projection  {
		} mac; */
	}
}
rpc u32 ixgbe_validate_eeprom_checksum_X540( projection hw * hw, u16* checksum_val ) {
	projection < struct ixgbe_hw > hw {
		/* projection  {
		} mac; */
	}
}
rpc u32 ixgbe_update_eeprom_checksum_X540( projection hw * hw ) {
	projection < struct ixgbe_hw > hw {
		/* projection  {
		} mac; */
	}
}
rpc u32 ixgbe_calc_eeprom_checksum_X540( projection hw * hw ) {
	projection < struct ixgbe_hw > hw {
	}
}
rpc void ixgbe_disable_rx_generic( projection hw * hw ) {
	projection < struct ixgbe_hw > hw {
		/* projection  {
		} mac; */
	}
}
rpc u32 ixgbe_get_invariants_82599( projection hw * hw ) {
	projection < struct ixgbe_hw > hw {
	}
}
rpc u32 ixgbe_identify_phy_82599( projection hw * hw ) {
	projection < struct ixgbe_hw > hw {
		/* projection  {
		} mac; */
	}
}
rpc u32 ixgbe_init_phy_ops_82599( projection hw * hw ) {
	projection < struct ixgbe_hw > hw {
	}
}
rpc u32 ixgbe_setup_mac_link_82599( projection hw * hw, u32 speed, bool autoneg_wait_to_complete ) {
	projection < struct ixgbe_hw > hw {
		/* projection  {
		} mac; */
	}
}
rpc u32 ixgbe_read_eeprom_82599( projection hw * hw, u16 offset, u16* data ) {
	projection < struct ixgbe_hw > hw {
	}
}
rpc u32 ixgbe_read_eeprom_buffer_82599( projection hw * hw, u16 offset, u16 words, u16* data ) {
	projection < struct ixgbe_hw > hw {
	}
}
rpc u32 ixgbe_write_eeprom_generic( projection hw * hw, u16 offset, u16 data ) {
	projection < struct ixgbe_hw > hw {
	}
}
rpc u32 ixgbe_write_eeprom_buffer_bit_bang_generic( projection hw * hw, u16 offset, u16 words, u16* data ) {
	projection < struct ixgbe_hw > hw {
	}
}
rpc u32 ixgbe_validate_eeprom_checksum_generic( projection hw * hw, u16* checksum_val ) {
	projection < struct ixgbe_hw > hw {
	}
}
rpc u32 ixgbe_update_eeprom_checksum_generic( projection hw * hw ) {
	projection < struct ixgbe_hw > hw {
	}
}
rpc u32 ixgbe_calc_eeprom_checksum_generic( projection hw * hw ) {
	projection < struct ixgbe_hw > hw {
	}
}
rpc u32 ixgbe_reset_hw_82599( projection hw * hw ) {
	projection < struct ixgbe_hw > hw {
		/* projection  {
		} mac; */
	}
}
rpc u32 ixgbe_start_hw_82599( projection hw * hw ) {
	projection < struct ixgbe_hw > hw {
		/* projection  {
		} mac; */
	}
}
rpc u32 ixgbe_get_media_type_82599( projection hw * hw ) {
	projection < struct ixgbe_hw > hw {
	}
}
rpc u32 ixgbe_read_analog_reg8_82599( projection hw * hw, u32 reg, u8* val ) {
	projection < struct ixgbe_hw > hw {
	}
}
rpc u32 ixgbe_write_analog_reg8_82599( projection hw * hw, u32 reg, u8 val ) {
	projection < struct ixgbe_hw > hw {
	}
}
rpc u32 ixgbe_setup_sfp_modules_82599( projection hw * hw ) {
	projection < struct ixgbe_hw > hw {
		/* projection  {
		} mac; */
	}
}
rpc_ptr u32 enable_rx_dma( projection hw * hw, u32 regval ) {
	projection < struct ixgbe_hw > hw {
		/* projection  {
		} mac; */
	}
}
rpc u32 ixgbe_acquire_swfw_sync( projection hw * hw, u32 mask ) {
	projection < struct ixgbe_hw > hw {
	}
}
rpc void ixgbe_release_swfw_sync( projection hw * hw, u32 mask ) {
	projection < struct ixgbe_hw > hw {
	}
}
rpc_ptr u32 prot_autoc_read( projection hw * hw, bool* locked, u32* reg_val ) {
	projection < struct ixgbe_hw > hw {
		/* projection  {
		} mac; */
	}
}
rpc_ptr u32 prot_autoc_write( projection hw * hw, u32 autoc, bool locked ) {
	projection < struct ixgbe_hw > hw {
		/* projection  {
		} mac; */
	}
}
rpc_ptr void stop_link_on_d3( projection hw * hw ) {
	projection < struct ixgbe_hw > hw {
	}
}
rpc u32 ixgbe_get_link_capabilities_82599( projection hw * hw, u32* speed, bool* autoneg ) {
	projection < struct ixgbe_hw > hw {
		/* projection  {
		} mac; */
	}
}
rpc u32 ixgbe_blink_led_start_generic( projection hw * hw, u32 index ) {
	projection < struct ixgbe_hw > hw {
		/* projection  {
		} mac; */
	}
}
rpc u32 ixgbe_blink_led_stop_generic( projection hw * hw, u32 index ) {
	projection < struct ixgbe_hw > hw {
		/* projection  {
		} mac; */
	}
}
rpc_ptr u32 get_thermal_sensor_data( projection hw * hw ) {
	projection < struct ixgbe_hw > hw {
		/* projection  {
		} mac; */
	}
}
rpc_ptr u32 init_thermal_sensor_thresh( projection hw * hw ) {
	projection < struct ixgbe_hw > hw {
		/* projection  {
		} mac; */
	}
}
rpc u32 ixgbe_get_invariants_82598( projection hw * hw ) {
	projection < struct ixgbe_hw > hw {
	}
}
rpc u32 ixgbe_init_phy_ops_82598( projection hw * hw ) {
	projection < struct ixgbe_hw > hw {
	}
}
rpc_ptr u32 read_i2c_sff8472( projection hw * hw, u8 byte_offset, u8* sff8472_data ) {
	projection < struct ixgbe_hw > hw {
	}
}
rpc_ptr u32 read_i2c_eeprom( projection hw * hw, u8 byte_offset, u8* eeprom_data ) {
	projection < struct ixgbe_hw > hw {
	}
}
rpc u32 ixgbe_reset_hw_82598( projection hw * hw ) {
	projection < struct ixgbe_hw > hw {
		/* projection  {
		} mac; */
	}
}
rpc u32 ixgbe_start_hw_82598( projection hw * hw ) {
	projection < struct ixgbe_hw > hw {
		/* projection  {
		} mac; */
	}
}
rpc u32 ixgbe_get_media_type_82598( projection hw * hw ) {
	projection < struct ixgbe_hw > hw {
	}
}
rpc_ptr void set_lan_id( projection hw * hw ) {
	projection < struct ixgbe_hw > hw {
	}
}
rpc_ptr u32 read_analog_reg8( projection hw * hw, u32 reg, u8* val ) {
	projection < struct ixgbe_hw > hw {
	}
}
rpc_ptr u32 write_analog_reg8( projection hw * hw, u32 reg, u8 val ) {
	projection < struct ixgbe_hw > hw {
	}
}
rpc u32 ixgbe_setup_mac_link_82598( projection hw * hw, u32 speed, bool autoneg_wait_to_complete ) {
	projection < struct ixgbe_hw > hw {
	}
}
rpc_ptr u32 check_link( projection hw * hw, u32* speed, bool* link_up, bool link_up_wait_to_complete ) {
	projection < struct ixgbe_hw > hw {
	}
}
rpc u32 ixgbe_get_link_capabilities_82598( projection hw * hw, u32* speed, bool* autoneg ) {
	projection < struct ixgbe_hw > hw {
		/* projection  {
		} mac; */
	}
}
rpc_ptr void set_rxpba( projection hw * hw, u32 num_pb, u32 headroom, u32 strategy ) {
	projection < struct ixgbe_hw > hw {
	}
}
rpc_ptr u32 set_vmdq( projection hw * hw, u32 rar, u32 vmdq ) {
	projection < struct ixgbe_hw > hw {
		/* projection  {
		} mac; */
	}
}
rpc_ptr u32 clear_vmdq( projection hw * hw, u32 rar, u32 vmdq ) {
	projection < struct ixgbe_hw > hw {
		/* projection  {
		} mac; */
	}
}
rpc_ptr u32 clear_vfta( projection hw * hw ) {
	projection < struct ixgbe_hw > hw {
		/* projection  {
		} mac; */
	}
}
rpc_ptr u32 set_vfta( projection hw * hw, u32 vlan, u32 vind, bool vlan_on, bool vlvf_bypass ) {
	projection < struct ixgbe_hw > hw {
	}
}
rpc_ptr u32 fc_enable( projection hw * hw ) {
	projection < struct ixgbe_hw > hw {
		/* projection  {
		} mac; */
	}
}
rpc void warn_slowpath_fmt( u8* file, u32 line, u8* fmt ) {
}
rpc void __const_udelay( u64 xloops ) {
}
rpc void __raw_spin_lock_init( projection lock * lock, u8* name, projection key * key ) {
	projection < struct raw_spinlock > lock {
		u32 [out] magic;
		u32 [out] owner_cpu;
		void* [out] owner;
	}
	projection < struct lock_class_key > key {
	}
}
rpc void msleep( u32 msecs ) {
}
rpc u32 del_timer_sync( projection timer * timer ) {
	projection < struct timer_list > timer {
	}
}
rpc void _raw_spin_unlock( projection lock * lock ) {
	projection < struct raw_spinlock > lock {
	}
}
rpc void init_timer_key( projection timer * timer, u32 flags, u8* name, projection key * key ) {
	projection < struct timer_list > timer {
	}
	projection < struct lock_class_key > key {
	}
}
rpc u8* skb_put( projection skb * skb, u32 len ) {
	projection < struct sk_buff > skb {
		u32 [out] len;
		//array [out] headers_end;
		u32 [out] tail;
		u32  end;
	}
}
rpc projection ret_sk_buff* __alloc_skb( u32 size, u32 gfp_mask, u32 flags, u32 node ) {
	projection < struct sk_buff >  ret_sk_buff {
		u8 [out] cloned;
		//array [out] headers_start;
		//array [out] __pkt_type_offset;
		u8 [out] pkt_type;
		u16 [out] transport_header;
		//array  headers_end;
		u32  tail;
		u32 [out] end;
		u8* [out] head;
		u8* [out] data;
	}
}

rpc projection ret_page* __alloc_pages_nodemask( u32 gfp_mask, u32 order, projection zonelist * zonelist, projection nodemask * nodemask ) {
	projection < struct page >  ret_page {
	}
	projection < struct zonelist > zonelist {
	}
	projection < struct  nodemask> nodemask {
	}
}
rpc void __free_pages( projection page * page, u32 order ) {
	projection < struct page > page {
	}
}
rpc void dev_warn( projection dev * dev, u8* fmt ) {
	projection < struct device > dev {
	}
}
rpc void dev_err( projection dev * dev, u8* fmt ) {
	projection < struct device > dev {
	}
}
rpc void _dev_info( projection dev * dev, u8* fmt ) {
	projection < struct device > dev {
	}
}
rpc void pci_dev_put( projection dev * dev ) {
	projection < struct pci_dev > dev {
	}
}
rpc bool queue_work_on( u32 cpu, projection wq * wq, projection work * work ) {
	projection < struct workqueue_struct > wq {
	}
	projection < struct work_struct > work {
	}
}
rpc u32 __bitmap_weight( u64* bitmap, u32 bits ) {
}
rpc u32 mod_timer( projection timer * timer, u64 expires ) {
	projection < struct timer_list > timer {
	}
}
rpc void __local_bh_enable_ip( u64 ip, u32 cnt ) {
}
rpc projection ret_dentry* debugfs_create_dir( u8* name, projection parent * parent ) {
	projection < struct dentry >  ret_dentry {
	}
	projection < struct dentry > parent {
	}
}
rpc projection ret_dentry* debugfs_create_file( u8* name, u16 mode, projection parent * parent, void* data, projection fops * fops ) {
	projection < struct dentry >  ret_dentry {
	}
	projection < struct dentry > parent {
	}
	projection < struct file_operations > fops {
		rpc_ptr read read;
		rpc_ptr write write;
	}
}
rpc void debugfs_remove_recursive( projection dentry * dentry ) {
	projection < struct dentry > dentry {
	}
}
rpc void kfree_skb( projection skb * skb ) {
	projection < struct sk_buff > skb {
	}
}
rpc u32 ___pskb_trim( projection skb * skb, u32 len ) {
	projection < struct sk_buff > skb {
		u32 [out] len;
		u32 [out] data_len;
	}
}
rpc u32 pskb_expand_head( projection skb * skb, u32 nhead, u32 ntail, u32 gfp_mask ) {
	projection < struct sk_buff > skb {
		u8 [out] cloned;
		//array [out] headers_end;
		u32 [out] tail;
		u32 [out] end;
		u8* [out] head;
		u8* [out] data;
	}
}
rpc void consume_skb( projection skb * skb ) {
	projection < struct sk_buff > skb {
	}
}
rpc u8* __pskb_pull_tail( projection skb * skb, u32 delta ) {
	projection < struct sk_buff > skb {
		u32 [out] data_len;
		//array [out] headers_end;
		u32 [out] tail;
		u32  end;
	}
}
rpc u32 skb_copy_bits( projection skb * skb, u32 offset, void* to, u32 len ) {
	projection < struct sk_buff > skb {
	}
}
rpc void skb_tstamp_tx( projection orig_skb * orig_skb, projection hwtstamps * hwtstamps ) {
	projection < struct sk_buff > orig_skb {
	}
	projection < struct skb_shared_hwtstamps > hwtstamps {
	}
}
rpc u64 ktime_get_with_offset( u32 toffs ) {
	projection < struct ktime > ktime_t {
	}
}
rpc u32 skb_pad( projection skb * skb, u32 pad ) {
	projection < struct sk_buff > skb {
		u32  len;
		u32  data_len;
		//array  headers_end;
		u32  tail;
		u32  end;
		u8*  data;
	}
}
rpc void napi_consume_skb( projection skb * skb, u32 budget ) {
	projection < struct sk_buff > skb {
		u8  cloned;
	}
}
rpc void __dev_kfree_skb_any( projection skb * skb, u32 reason ) {
	projection < struct sk_buff > skb {
	}
}
rpc projection ret_sk_buff* __napi_alloc_skb( projection napi * napi, u32 len, u32 gfp_mask ) {
	projection < struct sk_buff >  ret_sk_buff {
		u8 [out] cloned;
		//array [out] headers_start;
		//array [out] __pkt_type_offset;
		u8 [out] pkt_type;
	}
	projection < struct napi_struct > napi {
	}
}
rpc void napi_gro_flush( projection napi * napi, bool flush_old ) {
	projection < struct napi_struct > napi {
		projection gro_list* gro_list;
	}
	projection < struct sk_buff > gro_list {
	}
}
rpc void napi_complete_done( projection n * n, u32 work_done ) {
	projection < struct napi_struct > n {
		u64  state;
		projection gro_list* gro_list;
	}
	projection < struct sk_buff > gro_list {
	}
}
rpc void rtnl_unlock(  ) {
}
rpc void rtnl_lock(  ) {
}
rpc u32 call_netdevice_notifiers( u64 val, projection dev * dev ) {
	projection < struct net_device > dev {
	}
}
rpc u32 rtnl_is_locked(  ) {
}
rpc void kfree_call_rcu( projection head * head){ //, * func ) {
	projection < struct callback_head > head {
	}
}
rpc projection ret_rtnl_link_stats64* dev_get_stats( projection dev * dev, projection storage * storage ) {
	projection < struct rtnl_link_stats64 >  ret_rtnl_link_stats64 {
	}
	projection < struct net_device > dev {
		//projection _global_const struct net_device_ops* netdev_ops;
	}
	projection < struct rtnl_link_stats64 > storage {
	}
}
rpc void netif_schedule_queue( projection txq * txq ) {
	projection < struct netdev_queue > txq {
		u64  state;
	}
}
rpc void netdev_info( projection dev * dev, u8* fmt ) {
	projection < struct net_device > dev {
	}
}
rpc void netdev_warn( projection dev * dev, u8* fmt ) {
	projection < struct net_device > dev {
	}
}
rpc void netdev_err( projection dev * dev, u8* fmt ) {
	projection < struct net_device > dev {
	}
}
rpc void netdev_crit( projection dev * dev, u8* fmt ) {
	projection < struct net_device > dev {
	}
}
rpc void unregister_netdev( projection dev * dev ) {
	projection < struct net_device > dev {
	}
}
rpc void free_netdev( projection dev * dev ) {
	projection < struct net_device > dev {
		u32 [out] reg_state;
	}
}
rpc void netif_napi_del( projection napi * napi ) {
	projection < struct napi_struct > napi {
		projection gro_list* gro_list;
	}
	projection < struct sk_buff > gro_list {
	}
}
rpc bool napi_hash_del( projection napi * napi ) {
	projection < struct napi_struct > napi {
	}
}
rpc u32 register_netdev( projection dev * dev ) {
	projection < struct net_device > dev {
	}
}
rpc void __dynamic_netdev_dbg( projection descriptor * descriptor, projection dev * dev, u8* fmt ) {
	projection < struct _ddebug > descriptor {
	}
	projection < struct net_device > dev {
		/*projection  {
			projection struct device* parent;
		} dev;*/
	}
	projection < struct device > parent {
	}
}
rpc void netif_tx_stop_all_queues( projection dev * dev ) {
	projection < struct net_device > dev {
		u32  num_tx_queues;
	}
}
rpc void netif_carrier_on( projection dev * dev ) {
	projection < struct net_device > dev {
		u32  reg_state;
	}
}
rpc void netif_carrier_off( projection dev * dev ) {
	projection < struct net_device > dev {
		u32  reg_state;
	}
}
rpc projection ret_net_device* netdev_all_upper_get_next_dev_rcu( projection dev * dev, projection iter * iter ) {
	projection < struct net_device >  ret_net_device {
	}
	projection < struct net_device > dev {
		/*projection  {
		} all_adj_list;*/
	}
	projection < struct list_head > iter {
	}
}
rpc void napi_disable( projection n * n ) {
	projection < struct napi_struct > n {
	}
}
rpc void netif_napi_add( projection dev * dev, projection napi * napi, /* poll,*/ u32 weight ) {
	projection < struct net_device > dev {
		array< u8, 16>  name;
	}
	projection < struct napi_struct > napi {
		projection gro_list* gro_list;
	}
	projection < struct sk_buff > gro_list {
	}
}
rpc void __napi_schedule_irqoff( projection n * n ) {
	projection < struct napi_struct > n {
	}
}
rpc u32 napi_gro_receive( projection napi * napi, projection skb * skb ) {
	projection < struct napi_struct > napi {
	}
	projection < struct sk_buff > skb {
	}
}
rpc u32 netif_receive_skb( projection skb * skb ) {
	projection < struct sk_buff > skb {
	}
}
rpc u32 skb_checksum_help( projection skb * skb ) {
	projection < struct sk_buff > skb {
		u32  len;
		//array [out] headers_start;
		//array [out] __pkt_type_offset;
		u8 [out] pkt_type;
		u8*  data;
	}
}
rpc void netif_device_attach( projection dev * dev ) {
	projection < struct net_device > dev {
	}
}
rpc void netif_tx_wake_queue( projection dev_queue * dev_queue ) {
	projection < struct netdev_queue > dev_queue {
	}
}
rpc void netif_device_detach( projection dev * dev ) {
	projection < struct net_device > dev {
	}
}
rpc void netif_wake_subqueue( projection dev * dev, u16 queue_index ) {
	projection < struct net_device > dev {
	}
}
rpc u32 netif_set_real_num_rx_queues( projection dev * dev, u32 rxq ) {
	projection < struct net_device > dev {
		u32  num_rx_queues;
		u32  reg_state;
	}
}
rpc u32 netif_set_real_num_tx_queues( projection dev * dev, u32 txq ) {
	projection < struct net_device > dev {
		u32  num_tx_queues;
		u32  reg_state;
		u8  num_tc;
	}
}
rpc u32 netif_set_xps_queue( projection dev * dev, projection mask * mask, u16 index ) {
	projection < struct net_device > dev {
	}
	projection < struct cpumask > mask {
	}
}
rpc void netdev_rss_key_fill( void* buffer, u64 len ) {
}
rpc u32 ethtool_op_get_ts_info( projection dev * dev, projection info * info ) {
	projection < struct net_device > dev {
	}
	projection < struct ethtool_ts_info > info {
		u32 [out] so_timestamping;
		u32 [out] phc_index;
	}
}
rpc u32 ethtool_op_get_link( projection dev * dev ) {
	projection < struct net_device > dev {
	}
}
rpc u8* kasprintf( u32 gfp, u8* fmt ) {
}
rpc u32 ndo_dflt_bridge_getlink( projection skb * skb, u32 pid, u32 seq, projection dev * dev, u16 mode, u32 flags, u32 mask, u32 nlflags, u32 filter_mask/*, * vlan_fill*/ ) {
	projection < struct sk_buff > skb {
	}
	projection < struct net_device > dev {
		array< u8, 16>  name;
		u32  mtu;
		u8  addr_len;
		u8*  dev_addr;
	}
}
rpc u32 ndo_dflt_fdb_add( projection ndm * ndm, projection tb * tb, projection dev * dev, u8* addr, u16 vid, u16 flags ) {
	projection < struct ndmsg > ndm {
	}
	projection < struct nlattr > tb {
	}
	projection < struct net_device > dev {
		array< u8, 16>  name;
	}
}
rpc u32 ptp_clock_index( projection ptp * ptp ) {
	projection < struct ptp_clock > ptp {
	}
}
rpc void ptp_clock_event( projection ptp * ptp, projection event * event ) {
	projection < struct ptp_clock > ptp {
	}
	projection < struct ptp_clock_event > event {
		u32  type;
	}
}
rpc projection timespec ns_to_timespec( u64 nsec ) {
	projection < struct timespec > timespec {
	}
}
rpc u32 ptp_clock_unregister( projection ptp * ptp ) {
	projection < struct ptp_clock > ptp {
	}
}
rpc projection ret_ptp_clock* ptp_clock_register( projection info * info, projection parent * parent ) {
	projection < struct ptp_clock >  ret_ptp_clock {
	}
	projection < struct ptp_clock_info > info {
		projection owner* owner;
		u32  n_alarm;
		u32  pps;
	}
	projection < struct module > owner {
		rpc_ptr init init;
	}
	projection < struct device > parent {
	}
}
rpc projection ret_nlattr* nla_find( projection head * head, u32 len, u32 attrtype ) {
	projection < struct nlattr > ret_nlattr {
	}
	projection < struct nlattr > head {
	}
}
rpc u64 dev_trans_start( projection dev * dev ) {
	projection < struct net_device > dev {
		u32  num_tx_queues;
	}
}
rpc u32 ipv6_find_hdr( projection skb * skb, u32* offset, u32 target, u16* fragoff, u32* flags ) {
	projection < struct sk_buff > skb {
		u32  len;
	}
}
rpc u32 simple_read_from_buffer( void* to, u64 count, u64* ppos, const void* from, u64 available ) {
}
rpc u32 simple_write_to_buffer( void* to, u64 available, u64* ppos, const void* from, u64 count ) {
}
rpc u32 simple_open( projection inode * inode, projection file * file ) {
	projection < struct inode > inode {
	}
	projection < struct file > file {
		void* [out] private_data;
	}
}
rpc projection ret_workqueue_struct* __alloc_workqueue_key( u8* fmt, u32 flags, u32 max_active, projection key * key, u8* lock_name ) {
	projection < struct workqueue_struct >  ret_workqueue_struct {
	}
	projection < struct lock_class_key > key {
	}
}
rpc void destroy_workqueue( projection wq * wq ) {
	projection < struct workqueue_struct > wq {
	}
}
rpc u32 dev_addr_del( projection dev * dev, u8* addr, u8 addr_type ) {
	projection < struct net_device > dev {
		u8  addr_len;
	}
}
rpc u32 dev_addr_add( projection dev * dev, u8* addr, u8 addr_type ) {
	projection < struct net_device > dev {
		u8  addr_len;
	}
}
rpc void __hw_addr_unsync_dev( projection list * list, projection dev * dev /** ,unsync*/ ) {
	projection < struct netdev_hw_addr_list > list {
		/*projection  {
			projection struct list_head* next;
		} list;*/
	}
	projection < struct list_head > next {
	}
	projection < struct net_device > dev {
	}
}
rpc u32 __hw_addr_sync_dev( projection list * list, projection dev * dev /*, * sync, * unsync */ ) {
	projection < struct netdev_hw_addr_list > list {
		/*projection  {
			projection struct list_head* next;
		} list;*/
	}
	projection < struct list_head > next {
	}
	projection < struct net_device > dev {
	}
}
rpc u32 eth_platform_get_mac_address( projection dev * dev, u8* mac_addr ) {
	projection < struct device > dev {
	}
}
rpc projection ret_net_device* alloc_etherdev_mqs( u32 sizeof_priv, u32 txqs, u32 rxqs ) {
	projection < struct net_device >  ret_net_device {
	}
}
rpc u32 eth_validate_addr( projection dev * dev ) {
	projection < struct net_device > dev {
		u8*  dev_addr;
	}
}
rpc void __udelay( u64 usecs ) {
}
rpc void pci_unregister_driver( projection drv * drv ) {
	projection < struct pci_driver > drv {
		rpc_ptr probe probe;
		rpc_ptr remove remove;
		rpc_ptr resume resume;
		rpc_ptr shutdown shutdown;
		rpc_ptr sriov_configure sriov_configure;
	}
}
rpc u32 __pci_register_driver( projection drv * drv, projection owner * owner, u8* mod_name ) {
	projection < struct pci_driver > drv {
		const u8*  name;
		rpc_ptr probe probe;
		rpc_ptr remove remove;
		rpc_ptr resume resume;
		rpc_ptr shutdown shutdown;
		rpc_ptr sriov_configure sriov_configure;
		/*projection  {
			rpc_ptr probe probe;
			rpc_ptr remove remove;
			rpc_ptr shutdown shutdown;
			rpc_ptr resume resume;
		} driver;
		projection  {
		} dynids;*/
	}
	projection < struct module > owner {
		rpc_ptr init init;
	}
}
rpc u32 request_threaded_irq( u32 irq/*, * handler, * thread_fn*/, u64 irqflags, u8* devname, void* dev_id ) {
}
rpc void free_irq( u32 irq, void* dev_id ) {
}
rpc void synchronize_irq( u32 irq ) {
}
rpc u32 irq_set_affinity_hint( u32 irq, projection m * m ) {
	projection < struct cpumask > m {
	}
}
rpc u32 pci_select_bars( projection dev * dev, u64 flags ) {
	projection < struct pci_dev > dev {
		//array< struct resource, 11>  resource;
	}
}
rpc u32 pcie_get_minimum_link( projection dev * dev, u32 * speed, u32 * width ) {
	projection < struct pci_dev > dev {
		projection bus* bus;
	}
	projection < struct pci_bus > bus {
		projection self* self;
	}
	projection < struct pci_dev > self {
	}
}
rpc u32 pcie_capability_read_word( projection dev * dev, u32 pos, u16* val ) {
	projection < struct pci_dev > dev {
	}
}
rpc u32 pci_bus_read_config_word( projection bus * bus, u32 devfn, u32 pos, u16* value ) {
	projection < struct pci_bus > bus {
	}
}
rpc u32 pci_bus_write_config_word( projection bus * bus, u32 devfn, u32 pos, u16 value ) {
	projection < struct pci_bus > bus {
	}
}
rpc void pci_restore_state( projection dev * dev ) {
	projection < struct pci_dev > dev {
		u32 [out] transparent;
	}
}
rpc u32 pci_set_power_state( projection dev * dev, u32 state ) {
	projection < struct pci_dev > dev {
	}
}
rpc u32 pci_save_state( projection dev * dev ) {
	projection < struct pci_dev > dev {
		u32 [out] transparent;
	}
}
rpc void pci_disable_device( projection dev * dev ) {
	projection < struct pci_dev > dev {
		u32 [out] transparent;
	}
}
rpc void pci_set_master( projection dev * dev ) {
	projection < struct pci_dev > dev {
	}
}
rpc u32 pci_request_selected_regions( projection pdev * pdev, u32 bars, u8* res_name ) {
	projection < struct pci_dev > pdev {
	}
}
rpc void pci_release_selected_regions( projection pdev * pdev, u32 bars ) {
	projection < struct pci_dev > pdev {
	}
}
rpc u32 pci_wake_from_d3( projection dev * dev, bool enable ) {
	projection < struct pci_dev > dev {
	}
}
rpc u32 pci_enable_device_mem( projection dev * dev ) {
	projection < struct pci_dev > dev {
	}
}
rpc u8* ioremap_nocache( u64 phys_addr, u64 size ) {
}
projection < struct net_device_ops > _global_net_device_ops {
	rpc_ptr ndo_bridge_getlink ndo_bridge_getlink;
	rpc_ptr ndo_bridge_setlink ndo_bridge_setlink;
	rpc_ptr ndo_busy_poll ndo_busy_poll;
	rpc_ptr ndo_change_mtu ndo_change_mtu;
	rpc_ptr ndo_dfwd_add_station ndo_dfwd_add_station;
	rpc_ptr ndo_dfwd_del_station ndo_dfwd_del_station;
	rpc_ptr ndo_do_ioctl ndo_do_ioctl;
	rpc_ptr ndo_fdb_add ndo_fdb_add;
	rpc_ptr ndo_features_check ndo_features_check;
	rpc_ptr ndo_fix_features ndo_fix_features;
	rpc_ptr ndo_get_stats64 ndo_get_stats64;
	rpc_ptr ndo_get_vf_config ndo_get_vf_config;
	rpc_ptr ndo_open ndo_open;
	rpc_ptr ndo_select_queue ndo_select_queue;
	rpc_ptr ndo_set_features ndo_set_features;
	rpc_ptr ndo_set_mac_address ndo_set_mac_address;
	rpc_ptr ndo_set_rx_mode ndo_set_rx_mode;
	rpc_ptr ndo_set_tx_maxrate ndo_set_tx_maxrate;
	rpc_ptr ndo_set_vf_mac ndo_set_vf_mac;
	rpc_ptr ndo_set_vf_rate ndo_set_vf_rate;
	rpc_ptr ndo_set_vf_rss_query_en ndo_set_vf_rss_query_en;
	rpc_ptr ndo_set_vf_spoofchk ndo_set_vf_spoofchk;
	rpc_ptr ndo_set_vf_trust ndo_set_vf_trust;
	rpc_ptr ndo_set_vf_vlan ndo_set_vf_vlan;
	rpc_ptr ndo_setup_tc ndo_setup_tc;
	rpc_ptr ndo_start_xmit ndo_start_xmit;
	rpc_ptr ndo_stop ndo_stop;
	rpc_ptr ndo_tx_timeout ndo_tx_timeout;
	rpc_ptr ndo_udp_tunnel_add ndo_udp_tunnel_add;
	rpc_ptr ndo_udp_tunnel_del ndo_udp_tunnel_del;
	rpc_ptr ndo_vlan_rx_add_vid ndo_vlan_rx_add_vid;
	rpc_ptr ndo_vlan_rx_kill_vid ndo_vlan_rx_kill_vid;
}


}