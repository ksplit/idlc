module marshal_test {
	projection <struct b_struct> nested_proj {
		int [in, out] a;
	}

	projection <struct a_struct> bcallee_proj {
		unsigned [in, out] a;
		projection nested_proj [in, bind(callee)] * b;

		// [bind(callee)] is formally undefined in marshaling right now
		// You need to explicitly specify in or out, or it might not behave the way you expect it to
	}

	projection <struct a_struct> bcaller_proj {
		unsigned [in, out] a;
		projection nested_proj [in, bind(caller)] * b;
	}

	projection <struct d_struct> return_proj {
		unsigned [out] a;
	}

	projection <struct e_struct> return_bcallee_proj {
		projection return_proj [out, bind(callee)] * a;
		unsigned [out] b;
	}

	projection <struct e_struct> return_bcaller_proj {
		projection return_proj [out, bind(caller)] * a;
		unsigned [out] b;
	}

	rpc void pass_callee_bind_pointer(projection bcallee_proj [bind(callee)] * caller_pointer);
	rpc void pass_caller_bind_pointer(projection bcaller_proj [bind(caller)] * callee_pointer);
	rpc projection return_bcallee_proj [bind(callee)] * return_callee_bind_pointer();
	rpc projection return_bcaller_proj [bind(caller)] * return_caller_bind_pointer();

	rpc void pass_rpc(rpc rpc int (*)(int foo) (*rpc_pointer)(int foo));
	rpc rpc rpc int (*)(int foo) (*)(int foo) return_rpc();
	
	// Behavior with plain annotations (bind, as opposed to bind(caller)),
	// are ucrrently undefined, since it's not wholly clear what the semantics are
	// TODO: will be fixed

	// What is defined:
	// - [(in | out), (some other annotation)]
	// - [(in | out | (in, out))]
	// - 
	// TODO: add compiler pass to detect the weird stuff

	// Remarshaling is the most complex logic:
	// We have to remarshal all [out] fields, even if their parent pointers aren't
	// For marshaling, we can always ignore [out] argument subfields

	projection <struct a_struct> acallee_proj {
		unsigned [in, out] a;
		projection nested_proj [in, alloc(callee)] * b;

		// [bind(callee)] is formally undefined in marshaling right now
		// You need to explicitly specify in or out, or it might not behave the way you expect it to
	}

	projection <struct a_struct> acaller_proj {
		unsigned [in, out] a;
		projection nested_proj [in, alloc(caller)] * b;
	}

	projection <struct e_struct> return_acallee_proj {
		projection return_proj [out, alloc(callee)] * a;
		unsigned [out] b;
	}

	projection <struct e_struct> return_acaller_proj {
		projection return_proj [out, alloc(caller)] * a;
		unsigned [out] b;
	}

	rpc void pass_callee_alloc_pointer(projection acallee_proj [alloc(callee)] * caller_pointer);
	rpc void pass_caller_alloc_pointer(projection acaller_proj [alloc(caller)] * callee_pointer);
	rpc projection return_acallee_proj [alloc(callee)] * return_callee_alloc_pointer();
	rpc projection return_acaller_proj [alloc(caller)] * return_caller_alloc_pointer();
}