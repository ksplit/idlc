start-symbol: File


include: {{
#include "lcd_ast.h"
#include "error.h"
#include "utils.h"
#include <vector>
#include <stdlib.h>
#include <string>
#include <stdint.h>
}}

code: {{

typedef enum {
    IN = 0x1,
    OUT = 0x2,
    ALLOC_CALLER = 0x4,
    ALLOC_CALLEE = 0x8,
    DEALLOC_CALLER = 0x10,
    DEALLOC_CALLEE = 0x20,
    BIND_CALLER = 0x40,
    BIND_CALLEE = 0x80,
} spec_t;

LexicalScope *current_scope;
LexicalScope *current_module_scope;
LexicalScope *current_unnamed_scope;

void set_specs(Variable &v, const Value &s)
{
    // Since function arguments need to be marshalled across domains,
    // set a parameter to [in] if nothing is set. This avoids marking every
    // function parameter as [in]
    if (!s.getValue()) {
        v.set_in(true);
        return;
	}

    int spec = *((int*) s.getValue());

    if (spec & IN) {
        v.set_in(true);
    }
    if (spec & OUT) {
        v.set_out(true);
    }
    if (spec & ALLOC_CALLER) {
        v.set_alloc_caller(true);
    }
    if (spec & ALLOC_CALLEE) {
        v.set_alloc_callee(true);
    }
    if (spec & DEALLOC_CALLER) {
        v.set_dealloc_caller(true);
    }
    if (spec & DEALLOC_CALLEE) {
        v.set_dealloc_callee(true);
    }
    if (spec & BIND_CALLER) {
        v.set_bind_caller(true);
    }
    if (spec & BIND_CALLEE) {
        v.set_bind_callee(true);
    }
}

void set_current_scope(LexicalScope *ls)
{
    std::cout << "---> Current scope " << current_scope
        << " new scope " << ls << std::endl;
    current_scope = ls;
}

LexicalScope* get_current_scope()
{
    return current_scope;
}

void set_current_unnamed_scope(LexicalScope *ls)
{
    current_unnamed_scope = ls;
}

LexicalScope* get_current_unnamed_scope()
{
    return current_unnamed_scope;
}

void set_current_module_scope(LexicalScope *ls)
{
    current_module_scope = ls;
}

LexicalScope *get_current_module_scope()
{
    return current_module_scope;
}

Type *getType(const std::string& type)
{
    int err;
    LexicalScope *ls = get_current_scope();
    if(!ls) {
        std::cout << "current scope is null\n";
        ls = get_current_module_scope();
    }
    std::cout << "!Looking up for: " << type << " in scope: " << ls << "\n";

    Type* val = ls->lookup(type, &err);

    if(!val)
    {
        std::cout << "!ERROR: val is null for: " << type << " in scope: " << ls << "\n";
        val = new UnresolvedType(type);
    }
    return val;
}

Variable* getVariable(const std::string& id)
{
    int err;
    LexicalScope *ls = get_current_scope();
    if(!ls) {
        std::cout << "current scope is null!\n";
    }
    Variable *v = ls->lookup_variable(id, &err);

    if(!v) {
        std::cout << "could not find variable " <<  id << std::endl;
        return 0x0;
    }
    return v;
}

int count_pointers(Value v)
{
    int count = 0;
    for(Value::iterator it = v.getValues().begin(); it != v.getValues().end(); it++) {
        const Value & v2 = *it;
        char star = (char) (intptr_t) v2.getValue();
        std::cout << "supposed to be a star is " <<  star << std::endl;
        if(star == '*') {
           count += 1;
        } else {
           std::cout << "Not a star\n";
        }
    }
    return count;
}

void insertVariable(Variable *v)
{
    LexicalScope *ls = get_current_scope();
    bool ret = ls->insert(v);
    if(! ret)
    {
        ErrorReport* er = ErrorReport::instance();
        er->set_error();
        std::cout << "Error: variable by name " <<  v->identifier()
                    <<  " already exists in current scope" << std::endl;
    }
}

void insertType(const std::string& sym, Type * val) // should this be void?
{
    LexicalScope *ls = get_current_scope();
    bool ret = ls->insert(sym, val);

    std::cout << (ret ? "=> Inserting variable type " : "=> Could not insert type ")
				<< sym << " in scope " << ls << "\n";

    if(!ret)
    {
        ErrorReport* er = ErrorReport::instance();
        er->set_error();
        std::cout << "Error: type by name " <<  val->name()
                    <<  " already exists in current scope" << std::endl;
    }
}

const char* returnVarName()
{
    const char* name = "func_ret";
    while(get_current_scope()->contains_identifier(name)) {
        // append _ on end of name
        std::ostringstream total;
        total << name << "_";
        int len = total.str().length() + 1;
        char *new_name = new char[len];
        strncpy(new_name, total.str().c_str(), len);
        name = new_name;
    }
    return name;
}

void create_container(const Value &id, std::vector<ProjectionField*> &container_fields)
{
	const std::string *_id = static_cast<const std::string*>(id.getValue());

    container_fields.push_back(new ProjectionField(getType(*_id), *_id, 0));

    ProjectionField *other_ref = new ProjectionField(getType("cptr"), "other_ref", 0);
    other_ref->set_out(true);
    container_fields.push_back(other_ref);

    ProjectionField *my_ref = new ProjectionField(getType("cptr"), "my_ref", 0);
    my_ref->set_in(true);

    container_fields.push_back(my_ref);
}

}}

rules:


File		=	Spacing i:Include* t:Interface* <eof> {{
			    std::vector<Module*> modules;
			    std::vector<Include*> includes;
			
			    for(Value::iterator it = i.getValues().begin(); it != i.getValues().end(); it ++) {
			        const Value & v = *it;
			        includes.push_back((Include*) v.getValue());
			    }		       
			
			    for(Value::iterator it = t.getValues().begin(); it != t.getValues().end(); it ++) {
			        const Value & v2 = *it;
			        modules.push_back((Module*) v2.getValue());
			    }

			    value = new Project(LexicalScope::getGlobalScope(), modules, includes); 
			}}

Pathname	= 	p1:PathStart+ {{
			    std::ostringstream total;
			    
			    for(Value::iterator it = p1.getValues().begin(); it != p1.getValues().end(); it ++) {
			        const Value &v = *it;
				char c = (char) (intptr_t) v.getValue();
				total << c;
			    }
			    
			    std::string *str = new std::string(total.str().c_str());
			    value = str;
			}}

PathStart      	=	IdentCont | [./~]

Identifier	=	i1:IdentStart i2:IdentCont* {{ 
			    std::ostringstream total;
			    total << (char) (intptr_t) i1.getValue();

		   	    for(Value::iterator it = i2.getValues().begin(); it != i2.getValues().end(); it ++)
		   	    {   
			        const Value & v = *it;
				char letter = (char) (intptr_t) v.getValue();
				total << letter;
		   	    }
			    std::string *str = new std::string(total.str());
			    value = str;
			}}

IdentStart	=	[abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ_]

IdentCont	=	IdentStart | [0123456789]

unnamed_scope 	= 	s:unnamed_scope_special d:Type_Definitions* r:Rpc* Spacing CLOSEC Spacing {{
		            
			    std::vector<Rpc*> *rpcs = new std::vector<Rpc*>();
			    for(Value::iterator it = r.getValues().begin(); it != r.getValues().end(); it ++) {
			        const Value &v = *it;
				Rpc *r = (Rpc*) v.getValue();
				rpcs->push_back(r);
			    }
				LexicalScope *sc = (LexicalScope *)s.getValue();

			    set_current_scope(get_current_scope()->outer_scope()); // leaving current scope
			    value = rpcs;
			}}
			
unnamed_scope_special = Spacing OPENC Spacing {{
		      	    LexicalScope *tmp = get_current_module_scope();
		      	    LexicalScope *new_scope = new LexicalScope(tmp);
			    tmp->add_inner_scope(new_scope);
			    set_current_scope(new_scope);
		        std::cout << "# New Unnamed scope " << new_scope << " from: " << tmp << "\n";
			    set_current_unnamed_scope(new_scope);
			    value = new_scope;
			}}

pc_unnamed_scope_special = Spacing OPENC Spacing {{
			    LexicalScope *tmp = get_current_scope();
		      	    LexicalScope *new_scope = new LexicalScope(tmp);
			    tmp->add_inner_scope(new_scope);
			    set_current_scope(new_scope);
			    value = new_scope;
			 }}


pc_unnamed_scope=	s:pc_unnamed_scope_special d:Type_Definitions* p:ProjField* Spacing CLOSEC Spacing {{	
			    std::cout << "matched a pc unnamed scope\n";
			    std::vector<ProjectionField*> *fields = new std::vector<ProjectionField*>();
			    for(Value::iterator it = p.getValues().begin(); it != p.getValues().end(); it ++) {
			        const Value & v = *it;
				std::vector<ProjectionField*> *pf = (std::vector<ProjectionField*>*) v.getValue();
				fields->insert(fields->end(), pf->begin(), pf->end());
			    }
			    set_current_scope(get_current_scope()->outer_scope()); // leaving current scope
			    value = fields;
			}}

Interface	=	  m:Interface_special Space+ id:Identifier Spacing OPENC Spacing reqs:Require* d:Type_Definitions* r:Rpc* r2:unnamed_scope* Spacing CLOSEC Spacing {{
			LexicalScope *module_scope = (LexicalScope*) m.getValue();
			std::vector<Rpc*> rpcs;
			std::vector<GlobalVariable*> channels2;

			Channel::ChannelType ct = static_cast<Channel::ChannelType>(*((int*)new int(Channel::AsyncChannel)));

			std::cout << "New channel type: " << ct << " Initialized" << std::endl;
			const std::string _id("def_chnl");

			Channel *newCh = new Channel(_id, ct, NULL);
			// insert channel into type list
			std::cout << " new channel " << std::hex << newCh << std::dec << std::endl;
			insertType(_id, newCh);

			for(Value::iterator it = r.getValues().begin(); it != r.getValues().end(); it ++) {
				const Value & v2 = *it;
				Rpc *r2 = (Rpc*) v2.getValue();
				rpcs.push_back(r2);
			}

			for(Value::iterator it = r2.getValues().begin(); it != r2.getValues().end(); it ++) {
				const Value & v2 = *it;
				std::vector<Rpc*> *r_tmp = (std::vector<Rpc*>*) v2.getValue();
				rpcs.insert(rpcs.end(), r_tmp->begin(), r_tmp->end());
			}

			GlobalVariable *gv = new GlobalVariable(getType("cptr"), "def_chnl1", 0);
			insertVariable(gv);
			channels2.push_back(gv);

			Type *t = getType("def_chnl1");
			std::cout << "channel " << "def_chnl" << " Type information " << t << std::endl;

			module_scope->setactiveChannel(newCh);

			if (get_current_scope())
				set_current_scope(get_current_scope()->outer_scope()); // leaving current scope
			else
				set_current_scope(get_current_module_scope());
			const std::string *name = static_cast<const std::string*>(id.getValue());
			value = new Module(*name, rpcs, channels2, module_scope);
		}}

Require = "require" Spacing rmod:Identifier Spacing "on" Spacing ch_name:Identifier SEMI {{
    const std::string *_module = static_cast<const std::string*>(rmod.getValue());
    const std::string *_ch_name = static_cast<const std::string *>(ch_name.getValue());
    Channel *c = new Channel(*_ch_name, Channel::ChannelType::AsyncChannel, NULL);
    value = new Require(*_module, c);
}}

Interface_special =	  "module" {{
		  	      LexicalScope *new_scope = new LexicalScope(LexicalScope::getGlobalScope());
			      LexicalScope::getGlobalScope()->add_inner_scope(new_scope);
			      set_current_module_scope(new_scope);
			      set_current_scope(new_scope);
			      std::cout << "# Module scope " << new_scope << "\n";
			      value = new_scope;  
			  }}

Typedef		=	 "typedef" Spacing "<" Spacing rt:RealType "," Spacing mt:Type_form ">" Spacing id:Identifier Spacing {{ 
				const std::string *_id = static_cast<const std::string*>(id.getValue());
				const std::string *_rt = static_cast<const std::string*>(rt.getValue());

			     Typedef * val = new Typedef(*_id, *_rt, (Type*) mt.getValue());
			     insertType(*_id, val);
			 }}

Verbatim	=	 "verbatim" Spacing "[" contents:VerbatimContent "]" {{ std::ostringstream total;
			for(Value::iterator it = contents.getValues().begin(); it != contents.getValues().end(); it ++)
			{
			const Value &v = *it;
			char letter = (char) (intptr_t) v.getValue();
			total << letter;     
			}
			std::string str = total.str();
			value = &str[0]; }}

VerbatimContent =	!"]" .

RealType	=	fp:Identifier? Spacing sp:Identifier Spacing {{ //temporary solution
			std::ostringstream total;	     
			total << fp.getValue() << ' ' << sp.getValue();
			std::string *str = new std::string(total.str());
			value.value = str->c_str();
			}}		

String		=	<ascii 34> l:any_letter+ <ascii 34> {{
			    std::ostringstream total;
			    for(Value::iterator it = l.getValues().begin(); it != l.getValues().end(); it ++)
			    {
			        const Value & v = *it;
				char letter = (char) (intptr_t) v.getValue();
				
				if(letter == '\\')
				{
					if((it++) == l.getValues().end())
					{
						total << letter;
						break;
					}	
					
					letter = (char) (intptr_t) (*it).getValue();
					switch (letter)
					{
					case 'n':
					     total <<'\n';
					     break;
					case 't':
					     total << '\t';
					     break;
					default:
						total << letter;
					}
					continue;
				}
				total << letter;
			    }
			    std::string *str = new std::string(total.str());
			    value.value = str->c_str();
			}}

any_letter	=	[_.,/?<>'; =:%`!@#$^&*()-+{}|\\ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789]

Type_Definitions =	Typedef | Projection {{ std::cout << "done with projection\n"; }}
		 	| Projection_constructor

Include		 =	"include" Space+ "<" Spacing p:Pathname Spacing ">" Spacing{{
				const std::string *_path = static_cast<const std::string*>(p.getValue());
			    value = new Include(false, *_path);
			}} 
			| "include" Space+ <ascii 34> Spacing p:Pathname Spacing <ascii 34> Spacing{{
			    std::cout << "parsed an include\n";
				const std::string *_path = static_cast<const std::string*>(p.getValue());
			    value = new Include(true, *_path);
			}}

FP_Parameter	=	rpc_special Spacing s:Specification? rt:Type_form pointers:star* Spacing OPEN Spacing "*" Spacing id:Identifier Spacing CLOSE Spacing OPEN Spacing p:Parameters CLOSE {{

			    std::vector<Parameter*> *params = (std::vector<Parameter*>*) p.getValue();
				const std::string *_id = static_cast<const std::string*>(id.getValue());

			    Function *fp = new Function(*_id, new ReturnVariable((Type*) rt.getValue(), count_pointers(pointers), returnVarName())
			    	     	       		, *params, get_current_scope());

			    Parameter *_p = new Parameter(fp, *_id, 1);
			    set_specs(*_p, s);

				// XXX: Set scope to unnamed_scope as we need to insert definitions into that scope
				// definitions inserted into rpc scope is lost as rpc scope is not added to
				// unnamed scope's inner scopes
				set_current_scope(get_current_scope()->outer_scope());

			    insertType(*_id, fp);

			    // creating constructor
			    std::vector<ProjectionField*> container_fields;
			    create_container(id, container_fields);
			    const std::string container_name_str = container_name(*_id);
			    ProjectionType * container = new ProjectionType(container_name_str, container_name_str, container_fields);
			    std::cout << __func__ << ": Inserting projection type " << container_name_str << std::endl;
			    insertType(container_name_str, container);

				// XXX: Reset scope to current_unnamed_scope as nested so that nested function pointers
				// unwind properly. Blindly setting it to current_scope's outer_scope will hit global scope
				// sooner or later and cause SEGFAULT as global scope doesn't have any outer_scope
				std::cout << "Setting to current unnamed scope " << std::endl;
				set_current_scope(get_current_unnamed_scope());

			    value = _p;
			}}

FirstParam	=	"projection" Space+ id:Identifier Spacing s:Specification? pointers:star* Spacing field_id:Identifier Spacing OPEN Spacing args:Arguments Spacing CLOSE Spacing COMMA Spacing {{
			    
			    std::vector<Variable*> *arguments = (std::vector<Variable*>*) args.getValue();
				const std::string *_id = static_cast<const std::string*>(id.getValue());
			    InitializeType *it = new InitializeType(getType(*_id), *arguments);

			    int p_count = count_pointers(pointers);

			    Parameter *p = new Parameter(it, *_id, p_count); 
			    set_specs(*p, s);

				if (p->alloc_callee()) {
				   p->set_in(true);
				   p->set_out(true);
				} if (p->alloc_caller()) {
				   p->set_in(true); // not sure correct
				} if (p->dealloc_callee()) {
				   p->set_in(true);
				} if (p->dealloc_caller()) {
				   p->set_in(true);  // not sure correct
				} if (p->bind_callee() && p->alloc_caller()) {
				   p->set_out(true);   
				} if (p->bind_caller()) {
				   p->set_in(true);
				} if (p->bind_callee() && p->alloc_caller()) {
				   p->set_out(true);   
				} if (p->bind_caller()) {
				   p->set_in(true);
				}
			    
			    value = p;    
			}}	

 		|	  t:Type_form s:Specification? pointers:star* Spacing id:Identifier Spacing COMMA Spacing {{
			    int p_count = count_pointers(pointers);
				const std::string *_id = static_cast<const std::string*>(id.getValue());
			    Parameter *p = new Parameter((Type *) t.getValue(), *_id, p_count); 
			    set_specs(*p, s);

				if (p->alloc_callee()) {
				   p->set_in(true);
				   p->set_out(true);
				} if (p->alloc_caller()) {
				   p->set_in(true); // not sure correct
				} if (p->dealloc_callee()) {
				   p->set_in(true);
				} if (p->dealloc_caller()) {
				   p->set_in(true);  // not sure correct
				} if (p->bind_callee() && p->alloc_caller()) {
				   p->set_out(true);   
				} if (p->bind_caller()) {
				   p->set_in(true);
				}
			    
			    value = p;
			}}
			| fp_param:FP_Parameter Spacing COMMA Spacing {{
			    value = fp_param;
			}}

Arrow_or_Dot	= "->" | "."

Access_Start	= "container" | Identifier
Access_End	= Arrow_or_Dot id:Identifier {{
		      value = id;
		  }}
Access		= a1:Access_Start a2:Access_End* {{
		      
		  }}

FP_FirstParam	=	t:Type_form s:Specification? pointers:star* Spacing COMMA Spacing {{
			    FPParameter *fp = new FPParameter((Type*) t.getValue(), count_pointers(pointers));
			    set_specs(*fp, s);

				if (fp->alloc_callee()) {
				   fp->set_in(true);
				   fp->set_out(true);
				} if (fp->alloc_caller()) {
				   fp->set_in(true); // not sure correct
				} if (fp->dealloc_callee()) {
				   fp->set_in(true);
				} if (fp->dealloc_caller()) {
				   fp->set_in(true);  // not sure correct
				} if (fp->bind_callee() && fp->alloc_caller()) {
				   fp->set_out(true);   
				} if (fp->bind_caller()) {
				   fp->set_in(true);
				}
			    
			    value = fp;  
			}}
			| rpc_scope:rpc_special Space+ rt:Type_form pointers:star* Spacing OPEN Spacing "*" Spacing id:Identifier Spacing CLOSE Spacing OPEN Spacing p:Parameters CLOSE SEMI Spacing COMMA Spacing {{
			    std::vector<Parameter*> *params = (std::vector<Parameter*>*) p.getValue();
				const std::string *_id = static_cast<const std::string*>(id.getValue());

			    Function *fp = new Function(*_id, new ReturnVariable((Type*) rt.getValue(), count_pointers(pointers), returnVarName())
			                                , *params, (LexicalScope*)rpc_scope.getValue());

			    set_current_scope(get_current_scope()->outer_scope());
			    value = new FPParameter(fp, 1);
			}}
			  
LastParam	=	"projection" Space+ id:Identifier Spacing s:Specification? pointers:star* Spacing field_id:Identifier Spacing OPEN Spacing args:Arguments Spacing CLOSE Spacing {{
			    
			    std::vector<Variable*> *arguments = (std::vector<Variable*>*) args.getValue();
				const std::string *_id = static_cast<const std::string*>(id.getValue());

			    InitializeType *it = new InitializeType(getType(*_id), *arguments);

			    int p_count = count_pointers(pointers);

			    Parameter *p = new Parameter(it, *_id, p_count); 
			    set_specs(*p, s);

				if (p->alloc_callee()) {
				   p->set_in(true);
				   p->set_out(true);
				} if (p->alloc_caller()) {
				   p->set_in(true); // not sure correct
				} if (p->dealloc_callee()) {
				   p->set_in(true);
				} if (p->dealloc_caller()) {
				   p->set_in(true);  // not sure correct
				} if (p->bind_callee() && p->alloc_caller()) {
				   p->set_out(true);   
				} if (p->bind_caller()) {
				   p->set_in(true);
				}
			    
			    value = p;    
			}}	

 		|   t:Type_form s:Specification? pointers:star* Spacing id:Identifier Spacing {{
			    int p_count = count_pointers(pointers);
				const std::string *_id = static_cast<const std::string*>(id.getValue());

			    Parameter *p = new Parameter((Type *) t.getValue(), *_id, p_count); 
			    set_specs(*p, s);

				if (p->alloc_callee()) {
				   p->set_in(true);
				   p->set_out(true);
				} if (p->alloc_caller()) {
				   p->set_in(true); // not sure correct
				} if (p->dealloc_callee()) {
				   p->set_in(true);
				} if (p->dealloc_caller()) {
				   p->set_in(true);  // not sure correct
				} if (p->bind_callee() && p->alloc_caller()) {
				   p->set_out(true);   
				} if (p->bind_caller()) {
				   p->set_in(true);
				}
			
			    value = p;
			}}
			| fp_param:FP_Parameter Spacing {{
			    value = fp_param;
			}}

FP_LastParam	=	t:Type_form s:Specification? pointers:star* Spacing {{
			    FPParameter *fp = new FPParameter((Type*) t.getValue(), count_pointers(pointers));
			    set_specs(*fp, s);

				if (fp->alloc_callee()) {
				   fp->set_in(true);
				   fp->set_out(true);
				} if (fp->alloc_caller()) {
				   fp->set_in(true); // not sure correct
				} if (fp->dealloc_callee()) {
				   fp->set_in(true);
				} if (fp->dealloc_caller()) {
				   fp->set_in(true);  // not sure correct
				} if (fp->bind_callee() && fp->alloc_caller()) {
				   fp->set_out(true);   
				} if (fp->bind_caller()) {
				   fp->set_in(true);
				}

			    value = fp;
			}}
			|  rpc_special Space+ rt:Type_form pointers:star* Spacing OPEN Spacing "*" Spacing id:Identifier Spacing CLOSE Spacing OPEN Spacing p:Parameters CLOSE SEMI Spacing {{
			    // todo change return type to return variable and add pointer
			    std::vector<Parameter*> *params = (std::vector<Parameter*>*) p.getValue();
				const std::string *_id = static_cast<const std::string*>(id.getValue());

			    Function *fp = new Function(*_id, new ReturnVariable((Type*) rt.getValue(), count_pointers(pointers), returnVarName())
			                                , *params, get_current_scope());

			    set_current_scope(get_current_scope()->outer_scope());
			    value = new FPParameter(fp, 1);
			}}

Variable	=	Access | Identifier 

FirstArg	=	id:Identifier Spacing COMMA Spacing {{
			    // look up in scope.
				const std::string *_id = static_cast<const std::string*>(id.getValue());
			    Variable *v = getVariable(*_id);
			    value = v;    
			}}
LastArg		=	id:Identifier Spacing {{
			    // lookup in scope
				const std::string *_id = static_cast<const std::string*>(id.getValue());
			    Variable *v = getVariable(*_id);
			    value = v;
			}}

Arguments	=	first:FirstArg* last:LastArg {{
			    std::vector<Variable*> *args = new std::vector<Variable*>();
			    for(Value::iterator it = first.getValues().begin(); it != first.getValues().end(); it ++) { 
			        const Value &v = *it;
				Variable *var = (Variable*) v.getValue();
				args->push_back(var);    
			    }

			    args->push_back((Variable*) last.getValue());
			    value = args;
			}}

Parameters	=	f:FirstParam* l:LastParam {{
			    std::vector<Parameter* > *params = new std::vector<Parameter*>();
			    for(Value::iterator it = f.getValues().begin(); it != f.getValues().end(); it ++)
			    { 
			
				const Value & v = *it;
				Parameter* p = (Parameter* ) v.getValue();
				// put in scope too
				insertVariable(p);
				params->push_back(p);
			    }
			    params->push_back((Parameter* ) l.getValue());
			    value = params; 
			}} | <void> {{ value = new std::vector<Parameter*>(); }}		  

FP_Parameters	=	f:FP_FirstParam* l:FP_LastParam {{
		            std::cout << "matched fp parameters\n";
			    std::vector<FPParameter* > *params = new std::vector<FPParameter*>();
			    for(Value::iterator it = f.getValues().begin(); it != f.getValues().end(); it ++) { 
			
				const Value & v = *it;
				FPParameter* p = (FPParameter* ) v.getValue();
				params->push_back(p);
			    }
			    params->push_back((FPParameter* ) l.getValue());
			    value = params;
			}}

rpc_special     =      "rpc" {{
		           //LexicalScope *tmp = get_current_unnamed_scope();
			   //LexicalScope *new_scope = new LexicalScope(tmp);
			   // dont need to add to inner scope because rpc do not have type definitinos
			   //set_current_scope(new_scope);
			   //std::cout << "# New RPC scope(Not in any inner scope) " << new_scope << " from :" << tmp << "\n";
			   //value = new_scope;
			   value = get_current_module_scope();
		       }}


Rpc		=	rpc_scope:rpc_special Space+ t:Type_form s:Specification? pointers:star* Spacing id1:Identifier Spacing OPEN Spacing p:Parameters CLOSE SEMI Spacing {{
			    std::vector<Parameter*>* params = (std::vector<Parameter*>*) p.getValue();
			    std::vector<Parameter*> params_ = *params;
				const std::string *_id = static_cast<const std::string*>(id1.getValue());
                ReturnVariable *ret = new ReturnVariable((Type *) t.getValue(), count_pointers(pointers), returnVarName());
			    Rpc* r = new Rpc(ret, *_id, params_, (LexicalScope*) rpc_scope.getValue());
			    
			    set_specs(*ret, s);
			    std::cout << "creating an rpc\n";
			    /*
			    int err = get_current_scope()->insert(r);
			    if(!err) {
			        std::cout << "Error rpc already in scope with this name " <<  r->name() << std::endl;
		            }
			    */

			    //set_current_scope(get_current_unnamed_scope()); // leaving current scope
			    value = r; 
			}}  

Projection_constructor =    s:Projection_constructor_special Spacing "<" Spacing t:Proj_type Spacing ">" Spacing id:Identifier Spacing OPEN Spacing c:ProjArgs Spacing CLOSE Spacing OPENC Spacing cf:ChanField* d:Type_Definitions* p:ProjField* Spacing CLOSEC Spacing {{
		       	        std::vector<ProjectionField*> chan_fields;
				for(Value::iterator it = c.getValues().begin(); it != c.getValues().end(); it ++) {
			            const Value &v = *it;
				    ProjectionField *pf = (ProjectionField*) v.getValue();	
				    chan_fields.push_back(pf);
			        }


		       	        std::vector<ProjectionField*> fields;
				std::vector<ProjectionField*> *channels_ = (std::vector<ProjectionField*>*) c.getValue();
				std::vector<ProjectionField*> channels = *channels_;
				for(Value::iterator it = p.getValues().begin(); it != p.getValues().end(); it ++) {
				    const Value & v = *it;
				    std::vector<ProjectionField*> *tmp_ = (std::vector<ProjectionField*>*) v.getValue();
				    std::vector<ProjectionField*> tmp = *tmp_;
				    fields.insert(fields.end(), tmp.begin(), tmp.end());
				}

				const std::string *_id = static_cast<const std::string*>(id.getValue());
				const std::string *_type = static_cast<const std::string*>(t.getValue());

				ProjectionConstructorType *val = new ProjectionConstructorType(*_id, *_type, fields, chan_fields, channels);	

				// creating container
                std::vector<ProjectionField*> container_fields;
                create_container(id, container_fields);

				container_fields.insert(container_fields.end(), channels.begin(), channels.end());
				container_fields.insert(container_fields.end(), chan_fields.begin(), chan_fields.end());
			
                const std::string container_name_str = container_name(*_id);
                ProjectionType * container = new ProjectionType(container_name_str, container_name_str, container_fields);
				std::cout << "inserting container with name " <<  container_name_str << std::endl;
			    	
                // finished creating constructor
 				set_current_scope(get_current_scope()->outer_scope()); // leaving current scope
				insertType(*_id, val); // insert projection constructor
				insertType(container_name_str, container); // insert container
				value = val;
			    }}

Projection_constructor_special = "projection" {{
			       	     LexicalScope *tmp = get_current_scope();
			             LexicalScope *new_scope = new LexicalScope(tmp);
				     tmp->add_inner_scope(new_scope);
				     set_current_scope(new_scope);
				     value = new_scope;
				 }} 

Projection	=	"projection" Spacing "<" Spacing t:Proj_type Spacing ">" Spacing id:Identifier Spacing OPENC Spacing c:ChanField* p:ProjField* CLOSEC Spacing {{

			    std::vector<ProjectionField*> channels;
			    for(Value::iterator it = c.getValues().begin(); it != c.getValues().end(); it ++) {
			        const Value &v = *it;
				ProjectionField *pf = (ProjectionField*) v.getValue();	
				channels.push_back(pf);
			    }
 
			    std::vector<ProjectionField *> fields;
			    for(Value::iterator it = p.getValues().begin(); it != p.getValues().end(); it ++)
			    {
				const Value & v = *it;
				std::vector<ProjectionField*> *tmp_ = (std::vector<ProjectionField*>*) v.getValue();
				std::vector<ProjectionField*> tmp = *tmp_;
				fields.insert(fields.end(), tmp.begin(), tmp.end());
			    }

				const std::string *_id = static_cast<const std::string*>(id.getValue());
				//const std::string *_type = static_cast<const std::string*>(t.getValue());
			    const ProjectionType *_val = static_cast<const ProjectionType*>(t.getValue());
			    ProjectionType *val = new ProjectionType(*_val);
			    const std::string _type = val->real_type_;
			    val->setIdentifier(*_id);
			    val->setFields(fields);
			    //ProjectionType * val = new ProjectionType(*_id, *_type, fields, channels);
			    std::cout<<"id val is: "<<*_id<<std::endl;

			    insertType(*_id, val);

			    // creating constructor
                std::vector<ProjectionField*> container_fields;
                create_container(id, container_fields);

			    container_fields.insert(container_fields.end(), channels.begin(), channels.end());	    

			    const std::string container_name_str = container_name(*_id);
			    const std::string real_type_container = container_name(_type);
			    ProjectionType * container = new ProjectionType(container_name_str, real_type_container, container_fields);
			    std::cout << "inserting projection type with name " <<  container_name_str << std::endl;
			    insertType(container_name_str, container);
			    // finished creating constructor
 
			    value = val;
			 }}
		## what is the point of having a projection without at least one line

Proj_type	=  	pst:Proj_subtype Space+ id:Identifier Spacing {{
				const std::string *_type = static_cast<const std::string*>(id.getValue());
				const std::string *_pst = static_cast<const std::string*>(pst.getValue());
				ProjectionType::ProjectionSubType __pst;
				if (*_pst == "struct")
					__pst = ProjectionType::Struct;
				else if (*_pst == "union")
					__pst = ProjectionType::Union;	

			    	ProjectionType *val = new ProjectionType(*_type, __pst);
				std::cout << "Passed Proj_type rule" << std::endl;
				value = val;
			}}

Proj_subtype	=	"struct" {{
				value = new std::string("struct");
			}}
			| "union" {{
				value = new std::string("union");
			}}

Keyword		=     	"out" {{ 
			    int * x = new int(OUT);
			    value = x; 
			}}
			| "in" {{ 
			    int * x = new int(IN);
			    value = x; 
			}}
			| "alloc" Spacing OPEN Spacing "caller" Spacing CLOSE {{
			    int *x = new int(ALLOC_CALLER);
			    value = x;
			}}
			| "alloc" Spacing OPEN Spacing "callee" Spacing CLOSE {{
			    int *x = new int(ALLOC_CALLEE);
			    value = x;
			}}
			| "alloc" {{
			    int *x = new int(ALLOC_CALLER | ALLOC_CALLEE);
			    value = x; 
			}}
			| "dealloc" Spacing OPEN Spacing "caller" Spacing CLOSE {{
			    int *x = new int(DEALLOC_CALLER);
			    value = x;
			}}
			| "dealloc" Spacing OPEN Spacing "callee" Spacing CLOSE {{
			    int *x = new int(DEALLOC_CALLEE);
			    value = x;
			}}
			| "dealloc" {{
			    int *x = new int(DEALLOC_CALLEE | DEALLOC_CALLER);
			    value = x;
			}}
			| "bind" Spacing OPEN Spacing "callee" Spacing CLOSE {{
			    int *x = new int(BIND_CALLEE);
			    value = x;
			}}
			| "bind" Spacing OPEN Spacing "caller" Spacing CLOSE {{
			    int *x = new int(BIND_CALLER);
			    value = x;
			}}
			| "bind" {{
			    int *x = new int(BIND_CALLER | BIND_CALLEE);
			    value = x;
			}}

Start		=	k:Keyword Spacing COMMA Spacing {{ value = k; }}

Specification	=	OPENS Spacing s:Start* l:Last CLOSES Spacing {{
			    unsigned int *spec = new unsigned int();
			    for(Value::iterator it = s.getValues().begin(); it != s.getValues().end(); it ++) {		    
			    const Value & v = *it;
			    int* x = (int*) v.getValue();
			    if(!x) {
			        std::cout << "error x is null\n";
				exit(0);       
			    }
			    *spec |= *x;
			    }
			    int * y = (int *) l.getValue();
			    if(!y) { 
			        std::cout << "error y is null\n"; exit(0); 
			    }
			    *spec |= *y;
			    value = spec;
			}}

FirstProjArg    =      "channel" Space+ id:Identifier Spacing COMMA Spacing {{
				const std::string *name = static_cast<const std::string*>(id.getValue());
		           ProjectionField *pf = new ProjectionField(getType("cptr"), *name, 0);
			   insertVariable(pf); 
			   value = pf;
		       }}

LastProjArg     =      "channel" Space+ id:Identifier Spacing {{
				const std::string *name = static_cast<const std::string*>(id.getValue());
				ProjectionField *pf = new ProjectionField(getType("cptr"), *name, 0);
				insertVariable(pf);
				value = pf;
		       }}

ProjArgs        =       f:FirstProjArg* l:LastProjArg {{
			    std::vector<ProjectionField*> *channels = new std::vector<ProjectionField*>();

		    	    for(Value::iterator it = f.getValues().begin(); it != f.getValues().end(); it ++) {
			        const Value & v = *it;
				ProjectionField *gv = (ProjectionField*) v.getValue();
				channels->push_back(gv);
			    }
			    channels->push_back((ProjectionField*) l.getValue());
			    value = channels;
			}}

ChanField       =       "channel" Space+ s:Specification? Spacing id:Identifier Spacing SEMI Spacing {{
				const std::string *name = static_cast<const std::string*>(id.getValue());
			    ProjectionField *pf = new ProjectionField(getType("cptr"), *name, 0);
			    insertVariable(pf);
			    set_specs(*pf, s);

				if (pf->alloc_callee()) {
				   pf->set_in(true);
				   pf->set_out(true);
				} if (pf->alloc_caller()) {
				   pf->set_in(true); // not sure correct
				} if (pf->dealloc_callee()) {
				   pf->set_in(true);
				} if (pf->dealloc_caller()) {
				   pf->set_in(true);  // not sure correct
				} if (pf->bind_callee() && pf->alloc_caller()) {
				   pf->set_out(true);   
				} if (pf->bind_caller()) {
				   pf->set_in(true);
				}

			    value = pf;
			}}

ProjField	=	"projection" Space+ id:Identifier Spacing s:Specification? pointers:star* Spacing field_id:Identifier Spacing OPEN Spacing args:Arguments Spacing CLOSE Spacing SEMI Spacing {{
			    std::vector<Variable*> *arguments = (std::vector<Variable*>*) args.getValue();
				const std::string *name = static_cast<const std::string*>(id.getValue());
				const std::string *_fid = static_cast<const std::string*>(field_id.getValue());

	            InitializeType *it = new InitializeType(getType(*name), *arguments);

			    ProjectionField *pf = new ProjectionField(it, *_fid, count_pointers(pointers));
			    set_specs(*pf, s);


				if (pf->alloc_callee()) {
				   pf->set_in(true);
				   pf->set_out(true);
				} if (pf->alloc_caller()) {
				   pf->set_in(true); // not sure correct
				} if (pf->dealloc_callee()) {
				   pf->set_in(true);
				} if (pf->dealloc_caller()) {
				   pf->set_in(true);  // not sure correct
				} if (pf->bind_callee() && pf->alloc_caller()) {
				   pf->set_out(true);   
				} if (pf->bind_caller()) {
				   pf->set_in(true);
				}

			    std::vector<ProjectionField*> *fields = new std::vector<ProjectionField*>();
			    fields->push_back(pf);
			    value = fields; 
			    
			}}
			| t:Type_form Spacing s:Specification? pointers:star* Spacing id:Identifier Spacing SEMI Spacing {{ 
				const std::string *_id = static_cast<const std::string*>(id.getValue());

			    ProjectionField *pf = new ProjectionField((Type *) t.getValue(), *_id, count_pointers(pointers));
			    set_specs(*pf, s);

				if (pf->alloc_callee()) {
				   pf->set_in(true);
				   pf->set_out(true);
				} if (pf->alloc_caller()) {
				   pf->set_in(true); // not sure correct
				} if (pf->dealloc_callee()) {
				   pf->set_in(true);
				} if (pf->dealloc_caller()) {
				   pf->set_in(true);  // not sure correct
				} if (pf->bind_callee() && pf->alloc_caller()) {
				   pf->set_out(true);   
				} if (pf->bind_caller()) {
				   pf->set_in(true);
				}
			    
			    std::vector<ProjectionField*> *fields = new std::vector<ProjectionField*>();
			    fields->push_back(pf);
			    value = fields; 
			}}
			| rpc_special Spacing s:Specification? rt:Type_form s_rt:Specification? pointers:star* Spacing OPEN Spacing "*" Spacing id:Identifier Spacing CLOSE Spacing OPEN Spacing p:Parameters CLOSE SEMI Spacing {{
				const std::string *name = static_cast<const std::string*>(id.getValue());
			    std::vector<Parameter*> *params = (std::vector<Parameter*>*) p.getValue();
                ReturnVariable *ret = new ReturnVariable((Type*) rt.getValue(), count_pointers(pointers), returnVarName());
				Function *fp = new Function(*name, ret, *params, get_current_scope());
			    ProjectionField *pf = new ProjectionField(fp, *name, 1);
			    set_specs(*pf, s);
			    set_specs(*ret, s_rt);

			    std::vector<ProjectionField*> *fields = new std::vector<ProjectionField*>();
			    fields->push_back(pf);

			    set_current_scope(get_current_scope()->outer_scope());
			    value = fields;
			}}
			| pc_unnamed_scope

Last		=	k:Keyword Spacing {{ value = k; }}

Option		=	"projection"

star 		= 	[*]

signed_type	=	"int" Spacing {{ 
			    std::cout << "matched int type\n";
			    value = getType("int");
			}}
			| "char" Spacing {{
			    value = getType("char"); 
			}}   
			| "capability" Spacing {{ 
			    value = getType("capability"); 
			}}
			| "short" Spacing {{ 
			    value = getType("short");
			}}
			| "long"  Space+ "long" Space* Spacing {{
		 	    value = getType("long long");
			}}
			| "long" Spacing{{ 
			    value = getType("long"); 
			}}
			| "float" Spacing {{
			    value = getType("float");
			}}		
			| "double" Spacing {{
			    value = getType("double");
			}}
			| "bool" Spacing {{
			    value = getType("bool");
			}}

unsigned_type	=	"unsigned" Space+ "int" Spacing {{ 
			    value = getType("unsigned int"); 
			}} 
			| "unsigned" Space+ "char" Spacing {{ 
			    value = getType("unsigned char"); 
			}} 
			| "unsigned" Space+ "short" Spacing {{ 
			    value = getType("unsigned short"); 
			}} 
			| "unsigned" Space+ "long" Space+ "long" {{ 
			    value = getType("unsigned long long"); 
			}}
			| "unsigned" Space+ "long" Spacing {{ 
			    value = getType("unsigned long"); 
			}}

type 		=	unsigned_type
			| signed_type
			| "void" Spacing {{ value = getType("void"); }}

## just ignore the modules ones, not supporting right now

Type_form	=	"projection" Space+ n:Identifier Spacing {{
				const std::string *_id = static_cast<const std::string*>(n.getValue());
			    value = getType(*_id); 
			}}
			| "channel" Spacing {{  // todo
			    value = new Channel();
			}}
			| Qualifier? type


Qualifier	= Qualifiers+ Space+

Qualifiers	= "volatile" | "const"

Spacing		=	Space*

EndSpacing	=	EndSpace* 

Space		=	" " | "\t" | EndOfLine | Comment | Line_comment

EndSpace	= 	Space | Line_comment

EndOfLine	=	"\n" | "\r"

Comments	= 	Comment | Line_comment

Comment		=	Comment_start Comment_rest

Comment_rest	=	Comment_end
			| . Comment_rest

Comment_start	=	"/*"
Comment_end	=	"*/"


Line_comm_rest	=	Line_comm_end
			| . Line_comm_rest

Line_comm_start	=	"//"

Line_comment	=	Line_comm_start Line_comm_rest

Line_comm_end	=	"\n"

OPEN		=	"("
CLOSE		=	")"
SEMI		=	";"	
OPENC		=	"{"
CLOSEC		=	"}"
OPENA		=	"<"
CLOSEA		=	">"
OPENS		=	"["
CLOSES		=	"]"
COMMA		=	","
