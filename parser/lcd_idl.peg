start-symbol: File


include: {{ #include "lcd_ast.h"
	    #include "error.h"
	    #include <vector>
	    #include <stdlib.h>
	    #include <string>
	    #include <stdint.h> }}

code: {{
      LexicalScope *current_scope = 0x0;
      LexicalScope *current_module_scope = 0x0;

      const char* container_name(const char* name)
      {
          int length = strlen(name);
  	  int length2 = strlen("_container");
  	  char *new_str = (char*) malloc(sizeof(char)*(length+length2+1));

  	  std::ostringstream total;
  	  total << name << "_container";
  	  strncpy(new_str, total.str().c_str(), length+length2+1);
  	  return new_str;
      }

      void set_current_scope(LexicalScope *ls)
      {
          current_scope = ls;
      }

      LexicalScope* get_current_scope()
      {
          return current_scope;
      }

      void set_current_module_scope(LexicalScope *ls)
      {
          current_module_scope = ls;
      }

      LexicalScope* get_current_module_scope()
      {
          return current_module_scope;
      }

      Type * getType(const char* type)
      {	   
      	   int err;
	   LexicalScope *ls = get_current_scope();
	   if(!ls) {
	       printf("current scope is null\n");
	   }
	   Type* val = ls->lookup(type, &err);
	   

	   if(!val)
	   {	
	   	printf("val is null\n");
		val = new UnresolvedType(type);
	   }
	   return val;
      }	

      int count_pointers(Value v)
      {
          int count = 0;
	   for(Value::iterator it = v.getValues().begin(); it != v.getValues().end(); it++) {
	       const Value & v = *it;
	       char star = (char) (intptr_t) v.getValue();
	       if(star == '*') {
	           count += 1;
	       } else {
	           printf("Not a star\n");
	       }
	   }
	   return count;
      }			

      void insertType(const char * sym, Type * val) // should this be void?
      {
	LexicalScope *ls = get_current_scope();
	bool ret = ls->insert(sym, val);
	if(!ret)
	{
	    ErrorReport* er = ErrorReport::instance();
	    er->set_error();
	    printf("Error: type by name %s already exists in current scope.\n", val->name());
	}
      }	
}}

rules:


File		=	Spacing i:Include* GlobalScopeDefinitions t:Interface* <eof> {{
			    std::vector<Module*> modules;
			    std::vector<Include*> includes;
			
			    for(Value::iterator it = i.getValues().begin(); it != i.getValues().end(); it ++) {
			        const Value & v = *it;
			        includes.push_back((Include*) v.getValue());
			    }		       
			
			    for(Value::iterator it = t.getValues().begin(); it != t.getValues().end(); it ++) {
			        const Value & v2 = *it;
			        modules.push_back((Module*) v2.getValue());
			    }

			    value = new Project(GlobalScope::instance(), modules, includes); 
			}}

GlobalScopeDefinitions =      d:Type_Definitions* {{
		       	          printf("matched global scope definitions\n");
		       	          for(Value::iterator it = d.getValues().begin(); it != d.getValues().end(); it ++) { 
			    	      const Value & v2 = *it;
			    	      Type *type = (Type*) v2.getValue();
			    	      bool err = GlobalScope::instance()->insert(type->name(), type);
				      if(!err) {
				          printf("Error: definition already exists for a type of name %s in global scope.\n", type->name());
				      }
				  } 
			      }}

Pathname	= 	p1:PathStart+ {{
			    std::ostringstream total;
			    
			    for(Value::iterator it = p1.getValues().begin(); it != p1.getValues().end(); it ++) {
			        const Value &v = *it;
				char c = (char) (intptr_t) v.getValue();
				total << c;
			    }
			    
			    std::string str = total.str();
			    
			    value.value = malloc(str.length()+1);
			    strncpy((char*)value.value, str.c_str(), str.length()+1);
			}}

PathStart      	=	IdentCont | [./~]

Identifier	=	i1:IdentStart i2:IdentCont* {{ 
			    std::ostringstream total;
			    total << (char) (intptr_t) i1.getValue();

		   	    for(Value::iterator it = i2.getValues().begin(); it != i2.getValues().end(); it ++)
		   	    {   
			        const Value & v = *it;
				char letter = (char) (intptr_t) v.getValue();
				total << letter;
		   	    }
			    std::string str = total.str();
		   	    value.value = malloc(str.length()+1);
			    printf("matched identifier %s\n", str.c_str());
			    strncpy((char*)value.value, str.c_str(), str.length()+1); 
			}}

IdentStart	=	[abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ_-]

IdentCont	=	IdentStart | [0123456789]

unnamed_scope 	= 	s:unnamed_scope_special d:Type_Definitions* Rpc* Spacing CLOSEC Spacing {{
			    printf("matched an unnamed scope\n");
			    set_current_scope(get_current_scope()->outer_scope()); // leaving current scope
			    value = s;
			}}
			
unnamed_scope_special = Spacing OPENC Spacing {{
		      	    LexicalScope *tmp = get_current_module_scope();
		      	    LexicalScope *new_scope = new LexicalScope(tmp);
			    tmp->add_inner_scope(new_scope);
			    set_current_scope(new_scope);
			    value = new_scope;
			}}

pc_unnamed_scope=	s:unnamed_scope_special d:Type_Definitions* p:ProjField* Spacing CLOSEC Spacing {{	
			    printf("matched a pc unnamed scope\n");
			    std::vector<ProjectionField*> *fields = new std::vector<ProjectionField*>();
			    for(Value::iterator it = p.getValues().begin(); it != p.getValues().end(); it ++) {
			        const Value & v = *it;
				std::vector<ProjectionField*> *pf = (std::vector<ProjectionField*>*) v.getValue();
				fields->insert(fields->end(), pf->begin(), pf->end());
			    }
			    set_current_scope(get_current_scope()->outer_scope()); // leaving current scope
			    value = fields;
			}}

Interface	=	  m:Interface_special Space+ id:Identifier Spacing OPEN gs:Globals? Spacing CLOSE Spacing OPENC Spacing d:Type_Definitions* r:Rpc* unnamed_scope* Spacing CLOSEC Spacing {{ 
			      LexicalScope *module_scope = (LexicalScope*) m.getValue();
			      std::vector<Rpc*> rpcs;	 
			      std::vector<GlobalVariable*> *globals = (std::vector<GlobalVariable*>*) gs.getValue();  
			      std::vector<GlobalVariable*> globals2 = *globals;

			      for(Value::iterator it = r.getValues().begin(); it != r.getValues().end(); it ++) {
			          const Value & v2 = *it;
				  Rpc *r2 = (Rpc*) v2.getValue();
				  rpcs.push_back(r2);
			      }

			      set_current_scope(get_current_scope()->outer_scope()); // leaving current scope	  
			      value = new Module((char*) id.getValue(), rpcs, globals2, module_scope); 
			  }}

Interface_special =	  "module" {{
		  	      LexicalScope *new_scope = new LexicalScope(GlobalScope::instance());
			      GlobalScope::instance()->add_inner_scope(new_scope);
			      set_current_module_scope(new_scope);
			      set_current_scope(new_scope);
			      value = new_scope;  
			  }}

Typedef		=	 "typedef" Spacing "<" Spacing rt:RealType "," Spacing mt:Type_form ">" Spacing id:Identifier Spacing {{ 
			     Typedef * val = new Typedef((char*) rt.getValue(), (Type*) mt.getValue());
			     insertType((char*)id.getValue(),val);
			 }}

Verbatim	=	 "verbatim" Spacing "[" contents:VerbatimContent "]" {{ std::ostringstream total;
			for(Value::iterator it = contents.getValues().begin(); it != contents.getValues().end(); it ++)
			{
			const Value &v = *it;
			char letter = (char) (intptr_t) v.getValue();
			total << letter;     
			}
			std::string str = total.str();
			value = &str[0]; }}

VerbatimContent =	!"]" .

RealType	=	fp:Identifier? Spacing sp:Identifier Spacing {{ //temporary solution
			std::ostringstream total;	     
			total << fp.getValue() << ' ' << sp.getValue();
			std::string str = total.str();
			value.value = malloc(str.length()+1);
			strncpy((char*)value.value, str.c_str(), str.length()+1);
			}}		

String		=	<ascii 34> l:any_letter+ <ascii 34> {{
			    std::ostringstream total;
			    for(Value::iterator it = l.getValues().begin(); it != l.getValues().end(); it ++)
			    {
			        const Value & v = *it;
				char letter = (char) (intptr_t) v.getValue();
				
				if(letter == '\\')
				{
					if((it++) == l.getValues().end())
					{
						total << letter;
						break;
					}	
					
					letter = (char) (intptr_t) (*it).getValue();
					switch (letter)
					{
					case 'n':
					     total <<'\n';
					     break;
					case 't':
					     total << '\t';
					     break;
					default:
						total << letter;
					}
					continue;
				}
				total << letter;
			    }
			    std::string str = total.str();
			    value.value = malloc(str.length()+1);
			    strncpy((char*)value.value, str.c_str(), str.length()+1);
			}}

any_letter	=	[_.,/?<>'; =:%`!@#$^&*()-+{}|\\ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789]

Type_Definitions =	Typedef | Projection {{ printf("done with projection\n"); }}
		 	| Projection_constructor

Include		 =	"include" Space+ "<" Spacing p:Pathname Spacing ">" Spacing{{
			    value = new Include(true, (char*) p.getValue());
			}} 
		 	| "include" Space+ p:Pathname Spacing SEMI Spacing{{
			    printf("parsed an include\n");
			    value = new Include(false, (char*) p.getValue());
			}}

FP_Parameter	=	"rpc" Spacing s:Specification? rt:Type_form pointers:star* Spacing OPEN Spacing "*" Spacing id:Identifier Spacing CLOSE Spacing OPEN p:Parameters CLOSE {{
			    std::vector<Parameter*> *params = (std::vector<Parameter*>*) p.getValue();
			    Function *fp = new Function((char*) id.getValue(), new ReturnVariable((Type*) rt.getValue(), count_pointers(pointers)), *params);
			    
			    Parameter *p = new Parameter(fp, (char *) id.getValue(), 1);

			    if (s.getValue() != 0x0) {
			        std::vector<bool>* specs = (std::vector<bool>*) s.getValue();
			        if(specs->at(1)) {
			            p->set_out(true);
			    	} if(specs->at(2)) {
			            p->set_in(true);
			    	} if(specs->at(4)) {
			            p->set_alloc_caller(true);
			    	} if(specs->at(5)) {
			            p->set_alloc_callee(true);
			    	} if(specs->at(6) || specs->at(3)) {
			            p->set_alloc_callee(true);
				    p->set_alloc_caller(true);
			    	} if(specs->at(7) || specs->at(10)) {
				    p->set_dealloc_callee(true);
				    p->set_dealloc_caller(true);
				} if (specs->at(8)) {
				    p->set_dealloc_caller(true);
				} if (specs->at(9)) {
				    p->set_dealloc_callee(true);
				}
			    }

			    value = p;
			    
			}}

FirstParam	=	t:Type_form s:Specification? pointers:star* Spacing id:Identifier Spacing COMMA Spacing {{
			    
			    Parameter *p = new Parameter((Type *) t.getValue(), (char *) id.getValue(), count_pointers(pointers)); 
			    
			    if (s.getValue() != 0x0) {
			        std::vector<bool>* specs = (std::vector<bool>*) s.getValue();
			        if(specs->at(1)) {
			            p->set_out(true);
			    	} if(specs->at(2)) {
			            p->set_in(true);
			    	} if(specs->at(4)) {
			            p->set_alloc_caller(true);
			    	} if(specs->at(5)) {
			            p->set_alloc_callee(true);
			    	} if(specs->at(6) || specs->at(3)) {
			            p->set_alloc_callee(true);
				    p->set_alloc_caller(true);
			    	} if(specs->at(7) || specs->at(10)) {
				    p->set_dealloc_callee(true);
				    p->set_dealloc_caller(true);
				} if (specs->at(8)) {
				    p->set_dealloc_caller(true);
				} if (specs->at(9)) {
				    p->set_dealloc_callee(true);
				}
			    }
			    
			    value = p;
			}}
			| FP_Parameter Spacing COMMA Spacing

Arrow_or_Dot	= "->" | "."

Access_Start	= "container" | Identifier
Access_End	= Arrow_or_Dot id:Identifier {{
		      value = id;
		  }}
Access		= a1:Access_Start a2:Access_End* {{
		      
		  }}

FP_FirstParam	=	t:Type_form s:Specification? pointers:star* Spacing COMMA Spacing {{
			    FPParameter *fp = new FPParameter((Type*) t.getValue(), count_pointers(pointers));
			    if (s.getValue() != 0x0) {
			        std::vector<bool>* specs = (std::vector<bool>*) s.getValue();
			        if(specs->at(1)) {
			            fp->set_out(true);
			    	} if(specs->at(2)) {
			            fp->set_in(true);
			    	} if(specs->at(4)) {
			            fp->set_alloc_caller(true);
			    	} if(specs->at(5)) {
			            fp->set_alloc_callee(true);
			    	} if(specs->at(6) || specs->at(3)) {
			            fp->set_alloc_callee(true);
				    fp->set_alloc_caller(true);
			    	} if(specs->at(7) || specs->at(10)) {
				    fp->set_dealloc_callee(true);
				    fp->set_dealloc_caller(true);
				} if (specs->at(8)) {
				    fp->set_dealloc_caller(true);
				} if (specs->at(9)) {
				    fp->set_dealloc_callee(true);
				}
			    }

			    value = fp;  
			}}
			| "rpc" Space+ rt:Type_form pointers:star* Spacing OPEN Spacing "*" Spacing id:Identifier Spacing CLOSE Spacing OPEN p:Parameters CLOSE SEMI Spacing COMMA Spacing {{
			    std::vector<Parameter*> *params = (std::vector<Parameter*>*) p.getValue();
			    Function *fp = new Function((char*) id.getValue(), new ReturnVariable((Type*) rt.getValue(), count_pointers(pointers)), *params);
			    value = new FPParameter(fp, 1);
			}}
			  
LastParam	=	t:Type_form s:Specification? pointers:star* Spacing id:Identifier Spacing {{
			    Parameter *p = new Parameter((Type *) t.getValue(), (char *) id.getValue(), count_pointers(pointers)); 
			    			    
			    if (s.getValue() != 0x0) {
			        std::vector<bool>* specs = (std::vector<bool>*) s.getValue();
			    	if(specs->at(1)) {
			            p->set_out(true);
			    	} if(specs->at(2)) {
			            p->set_in(true);
			    	} if(specs->at(4)) {
			            p->set_alloc_caller(true);
			    	} if(specs->at(5)) {
			            p->set_alloc_callee(true);
			    	} if(specs->at(6) || specs->at(3)) {
			            p->set_alloc_callee(true);
				    p->set_alloc_caller(true);
			    	} if(specs->at(7) || specs->at(10)) {
				    p->set_dealloc_callee(true);
				    p->set_dealloc_caller(true);
				} if (specs->at(8)) {
				    p->set_dealloc_caller(true);
				} if (specs->at(9)) {
				    p->set_dealloc_callee(true);
				}
			    }
			
			    value = p;
			}}
			| FP_Parameter Spacing

FP_LastParam	=	t:Type_form s:Specification? pointers:star* Spacing {{
			    FPParameter *fp = new FPParameter((Type*) t.getValue(), count_pointers(pointers));
			    if(s.getValue() != 0x0) {
			        std::vector<bool>* specs = (std::vector<bool>*) s.getValue();
			        if(specs->at(1)) {
			            fp->set_out(true);
			    	} if(specs->at(2)) {
			            fp->set_in(true);
			    	} if(specs->at(4)) {
			            fp->set_alloc_caller(true);
			    	} if(specs->at(5)) {
			            fp->set_alloc_callee(true);
			    	} if(specs->at(6) || specs->at(3)) {
			            fp->set_alloc_callee(true);
				    fp->set_alloc_caller(true);
			    	} if(specs->at(7) || specs->at(10)) {
				    fp->set_dealloc_callee(true);
				    fp->set_dealloc_caller(true);
				} if (specs->at(8)) {
				    fp->set_dealloc_caller(true);
				} if (specs->at(9)) {
				    fp->set_dealloc_callee(true);
				}
			    }

			    value = fp;
			}}
			|  "rpc" Space+ rt:Type_form pointers:star* Spacing OPEN Spacing "*" Spacing id:Identifier Spacing CLOSE Spacing OPEN p:Parameters CLOSE SEMI Spacing {{
			    // todo change return type to return variable and add pointer
			    std::vector<Parameter*> *params = (std::vector<Parameter*>*) p.getValue();
			    Function *fp = new Function((char*) id.getValue(), new ReturnVariable((Type*) rt.getValue(), count_pointers(pointers)), *params);
			    value = new FPParameter(fp, 1);
			}}

Variable	=	Access | Identifier 

FirstArg	=	Variable Spacing COMMA Spacing {{
			    // todo
			}}
LastArg		=	Variable Spacing {{
			    // todo
			}}

Arguments	=	first:FirstArg* last:LastArg {{
			    // todo
			}}

Parameters	=	f:FirstParam* l:LastParam {{
			    std::vector<Parameter* > *params = new std::vector<Parameter*>();
			    for(Value::iterator it = f.getValues().begin(); it != f.getValues().end(); it ++)
			    { 
			
				const Value & v = *it;
				Parameter* p = (Parameter* ) v.getValue();
				params->push_back(p);
			    }
			    params->push_back((Parameter* ) l.getValue());
			    value = params; 
			}}

FirstGlobal	=	t:Type_form pointers:star* Spacing id:Identifier Spacing COMMA Spacing {{
			    value = new GlobalVariable((Type*) t.getValue(), (char*) id.getValue(), count_pointers(pointers));
			}}

LastGlobal	=	t:Type_form pointers:star* Spacing id:Identifier Spacing {{
			    value = new GlobalVariable((Type*) t.getValue(), (char*) id.getValue(), count_pointers(pointers));
			}}

Globals 	=	f:FirstGlobal* l:LastGlobal {{
		 	    printf("matched globals\n");
			    std::vector<GlobalVariable*> *globals = new std::vector<GlobalVariable*>();
			    for(Value::iterator it = f.getValues().begin(); it != f.getValues().end(); it ++) {
			        const Value & v = *it;
				GlobalVariable *gv = (GlobalVariable*) v.getValue();
				globals->push_back(gv);
			    }
			    globals->push_back((GlobalVariable*) l.getValue());
			    value = globals;
			}}

FP_Parameters	=	f:FP_FirstParam* l:FP_LastParam {{
		            printf("matched fp parameters\n");
			    std::vector<FPParameter* > *params = new std::vector<FPParameter*>();
			    for(Value::iterator it = f.getValues().begin(); it != f.getValues().end(); it ++) { 
			
				const Value & v = *it;
				FPParameter* p = (FPParameter* ) v.getValue();
				params->push_back(p);
			    }
			    params->push_back((FPParameter* ) l.getValue());
			    value = params;
			}}


Rpc		=	"rpc" Space+ t:Type_form pointers:star* Spacing id1:Identifier Spacing OPEN p:Parameters CLOSE SEMI Spacing {{
			    std::vector<Parameter*>* params = (std::vector<Parameter*>*) p.getValue();
			    std::vector<Parameter*> params_ = *params;
			    Rpc* r = new Rpc(new ReturnVariable((Type *) t.getValue(), count_pointers(pointers)), (char *) id1.getValue(), params_, get_current_scope());
			    
			    /*
			    int err = get_current_scope()->insert(r);
			    if(!err) {
			        printf("Error rpc already in scope with this name %s.\n", r->name());
		            }
			    */
			    value = r; 
			}}  

Projection_constructor =    s:Projection_constructor_special Spacing "<" Spacing t:Proj_type Spacing ">" Spacing id:Identifier Spacing OPEN Spacing g:Globals? Spacing CLOSE Spacing OPENC Spacing d:Type_Definitions* p:ProjField* Spacing CLOSEC Spacing {{
		                printf("matched a projection constructor\n");
		       	        std::vector<ProjectionField*> fields;
				std::vector<GlobalVariable*> *globals_ = (std::vector<GlobalVariable*>*) g.getValue();
				std::vector<GlobalVariable*> globals = *globals_;
				for(Value::iterator it = p.getValues().begin(); it != p.getValues().end(); it ++) {
				    const Value & v = *it;
				    std::vector<ProjectionField*> *tmp_ = (std::vector<ProjectionField*>*) v.getValue();
				    std::vector<ProjectionField*> tmp = *tmp_;
				    fields.insert(fields.end(), tmp.begin(), tmp.end());
				}

				ProjectionType *val = new ProjectionType((char*) id.getValue(), (char*) t.getValue(), fields, globals);	
				insertType((char*) id.getValue(), val);
				set_current_scope(get_current_scope()->outer_scope()); // leaving current scope
				
				// creating constructor
			    	std::vector<ProjectionField*> container_fields;
			    	container_fields.push_back(new ProjectionField(getType((char*)id.getValue()), (char*)id.getValue(), 0));
			    	container_fields.push_back(new ProjectionField(getType("dptr_t"), "other_ref", 0));
			    	container_fields.push_back(new ProjectionField(getType("dptr_t"), "my_ref", 0));
			    	// may need to add extra fields here.
			    	const char *container_name_str = container_name((char*)id.getValue());
			    	ProjectionType * container = new ProjectionType(container_name_str, container_name_str, container_fields);
			    	insertType(container_name_str, container);
			    	// finished creating constructor
 
				value = val;
			    }}

Projection_constructor_special = "projection" {{
			       	     LexicalScope *tmp = get_current_scope();
			             LexicalScope *new_scope = new LexicalScope(tmp);
				     tmp->add_inner_scope(new_scope);
				     set_current_scope(new_scope);
				     value = new_scope;
				 }} 

Projection	=	"projection" Spacing "<" Spacing t:Proj_type Spacing ">" Spacing id:Identifier Spacing OPENC Spacing p:ProjField* CLOSEC Spacing {{ 
			    printf("matched a projection\n");
			    std::vector<ProjectionField *> fields;
			    for(Value::iterator it = p.getValues().begin(); it != p.getValues().end(); it ++)
			    {
				const Value & v = *it;
				std::vector<ProjectionField*> *tmp_ = (std::vector<ProjectionField*>*) v.getValue();
				std::vector<ProjectionField*> tmp = *tmp_;
				fields.insert(fields.end(), tmp.begin(), tmp.end());
			    } 
			    ProjectionType * val = new ProjectionType((char* ) id.getValue(), (char*) t.getValue(), fields);
			    insertType((char*)id.getValue(), val);

			    // creating constructor
			    std::vector<ProjectionField*> container_fields;
			    container_fields.push_back(new ProjectionField(getType((char*)id.getValue()), (char*)id.getValue(), 0));
			    container_fields.push_back(new ProjectionField(getType("dptr_t"), "other_ref", 0));
			    container_fields.push_back(new ProjectionField(getType("dptr_t"), "my_ref", 0));
			    // may need to add extra fields here.
			    const char *container_name_str = container_name((char*)id.getValue());
			    ProjectionType * container = new ProjectionType(container_name_str, container_name_str, container_fields);
			    insertType(container_name_str, container);
			    // finished creating constructor
 
			    value = val;
			 }}
		## what is the point of having a projection without at least one line

Proj_type	=  	"struct" Space+ id:Identifier Spacing {{
			value = id;}}

Keyword		=     	"out" {{ 
			    int * x = (int *) malloc(sizeof(int));
			    *x = 1;
			    value = x; 
			}}
			| "in" {{ 
			    int * x = (int *) malloc(sizeof(int));
			    *x = 2; 
			    value = x; 
			}}
			| "alloc" Spacing OPEN Spacing "caller" Spacing "," "callee" Spacing CLOSE {{
			    int *x = (int*) malloc(sizeof(int)); 
			    *x = 6;
			    value = x;
			}}
			| "alloc" Spacing OPEN Spacing "caller" Spacing CLOSE {{
			    int *x = (int*) malloc(sizeof(int));
			    *x = 4;
			    value = x;
			}}
			| "alloc" Spacing OPEN Spacing "callee" Spacing CLOSE {{
			    int *x = (int*) malloc(sizeof(int));
			    *x = 5;
			    value = x;
			}}
			| "alloc" {{
			    printf("matched alloc keyword\n"); 
			    int *x = (int *) malloc(sizeof(int));
			    *x = 3;
			    value = x; 
			}}
			| "dealloc" Spacing OPEN Spacing "caller" Spacing "," "callee" Spacing CLOSE {{
			    int *x = (int*) malloc(sizeof(int));
			    *x = 7;
			    value = x;
			}}  
			| "dealloc" Spacing OPEN Spacing "caller" Spacing CLOSE {{
			    int *x = (int*) malloc(sizeof(int));
			    *x = 8;
			    value = x;
			}}
			| "dealloc" Spacing OPEN Spacing "callee" Spacing CLOSE {{
			    int *x = (int*) malloc(sizeof(int));
			    *x = 9;
			    value = x;
			}}
			| "dealloc" {{
			    int *x = (int*) malloc(sizeof(int));
			    *x = 10;
			    value = x;
			}}							
			
Start		=	k:Keyword Spacing COMMA Spacing {{ value = k; }}

Specification	=	OPENS Spacing s:Start* l:Last CLOSES Spacing {{
			    std::vector<bool>* specs = new std::vector<bool>(11, false);
			    for(Value::iterator it = s.getValues().begin(); it != s.getValues().end(); it ++) {		    
			    const Value & v = *it;
			    int* x = (int*) v.getValue();
			    if(!x) {
			        printf("error x is null\n");
				exit(0);       
			    }
			    specs->at(*x) = true;
			}
			    int * y = (int *) l.getValue();
			    if(!y) { 
			        printf("error y is null\n"); exit(0); 
			    }
			    specs->at(*y) = true;
			    value = specs; 
			}}

ProjField	=	"projection" Space+ id:Identifier Spacing s:Specification? pointers:star* Spacing field_id:Identifier Spacing OPEN Spacing args:Arguments Spacing CLOSE Spacing SEMI Spacing {{
			    ProjectionField *pf = new ProjectionField(getType((char*) id.getValue()), (char*) field_id.getValue(), count_pointers(pointers));
			    
			    if (s.getValue() != 0x0) {
			        std::vector<bool>* specs = (std::vector<bool>*) s.getValue();
			        if(specs->at(1)) {
			            pf->set_out(true);
			    	} if(specs->at(2)) {
			            pf->set_in(true);
			    	} if(specs->at(4)) {
			            pf->set_alloc_caller(true);
			    	} if(specs->at(5)) {
			            pf->set_alloc_callee(true);
			    	} if(specs->at(6) || specs->at(3)) {
			            pf->set_alloc_callee(true);
				    pf->set_alloc_caller(true);
			    	} if(specs->at(7) || specs->at(10)) {
				    pf->set_dealloc_callee(true);
				    pf->set_dealloc_caller(true);
				} if (specs->at(8)) {
				    pf->set_dealloc_caller(true);
				} if (specs->at(9)) {
				    pf->set_dealloc_callee(true);
				}
			    }

			    std::vector<ProjectionField*> *fields = new std::vector<ProjectionField*>();
			    fields->push_back(pf);
			    value = fields; 
			    
			}}
			| t:Type_form Spacing s:Specification? pointers:star* Spacing id:Identifier Spacing SEMI Spacing {{ 
			    printf("matched a regular projection field\n");

			    ProjectionField *pf = new ProjectionField((Type *) t.getValue(), (char *) id.getValue(), count_pointers(pointers));

			    if (s.getValue() != 0x0) {
			        std::vector<bool>* specs = (std::vector<bool>*) s.getValue();
			        if(specs->at(1)) {
			            pf->set_out(true);
			    	} if(specs->at(2)) {
			            pf->set_in(true);
			    	} if(specs->at(4)) {
			            pf->set_alloc_caller(true);
			    	} if(specs->at(5)) {
			            pf->set_alloc_callee(true);
			    	} if(specs->at(6) || specs->at(3)) {
			            pf->set_alloc_callee(true);
				    pf->set_alloc_caller(true);
			    	} if(specs->at(7) || specs->at(10)) {
				    pf->set_dealloc_callee(true);
				    pf->set_dealloc_caller(true);
				} if (specs->at(8)) {
				    pf->set_dealloc_caller(true);
				} if (specs->at(9)) {
				    pf->set_dealloc_callee(true);
				}
			    }
			    
			    std::vector<ProjectionField*> *fields = new std::vector<ProjectionField*>();
			    fields->push_back(pf);
			    value = fields; 
			}}
			| "rpc" Spacing s:Specification? rt:Type_form pointers:star* Spacing OPEN Spacing "*" Spacing id:Identifier Spacing CLOSE Spacing OPEN p:Parameters CLOSE SEMI Spacing {{
			    printf("matched a function pointer field\n");
			    
			    std::vector<Parameter*> *params = (std::vector<Parameter*>*) p.getValue();
			    Function *fp = new Function((char*) id.getValue(), new ReturnVariable((Type*) rt.getValue(), count_pointers(pointers)), *params);
			    ProjectionField *pf = new ProjectionField(fp, (char*) id.getValue(), 1);

			    if (s.getValue() != 0x0) {
			        std::vector<bool> *specs = (std::vector<bool>*) s.getValue();
			        if(specs->at(1)) {
			            pf->set_out(true);
			    	} if(specs->at(2)) {
			            pf->set_in(true);
			    	} if(specs->at(4)) {
			            pf->set_alloc_caller(true);
			    	} if(specs->at(5)) {
			            pf->set_alloc_callee(true);
			    	} if(specs->at(6) || specs->at(3)) {
			            pf->set_alloc_callee(true);
				    pf->set_alloc_caller(true);
			    	} if(specs->at(7) || specs->at(10)) {
				    pf->set_dealloc_callee(true);
				    pf->set_dealloc_caller(true);
				} if (specs->at(8)) {
				    pf->set_dealloc_caller(true);
				} if (specs->at(9)) {
				    pf->set_dealloc_callee(true);
				}
			    }

			    std::vector<ProjectionField*> *fields = new std::vector<ProjectionField*>();
			    fields->push_back(pf);
			    value = fields;
			}}
			| pc_unnamed_scope

Last		=	k:Keyword Spacing {{ value = k; }}

Option		=	"projection"

star 		= 	[*] {{ 	 
			    printf("matched a star\n");
			}}

signed_type	=	"int" Spacing {{ 
			    printf("matched int type\n");
			    value = getType("int");
			}}
			| "char" {{ 
			    value = getType("char"); 
			}}   
			| "capability" Spacing {{ 
			    value = getType("capability"); 
			}}
			| "short" Spacing {{ 
			    value = getType("short");
			}}
			| "long"  Space+ "long" Space* Spacing {{
		 	    value = getType("long long");
			}}
			| "long" Spacing{{ 
			    value = getType("long"); 
			}}

unsigned_type	=	"unsigned" Space+ "int" Spacing {{ 
			    value = getType("unsigned int"); 
			}} 
			| "unsigned" Space+ "char" Spacing {{ 
			    value = getType("unsigned char"); 
			}} 
			| "unsigned" Space+ "short" Spacing {{ 
			    value = getType("unsigned short"); 
			}} 
			| "unsigned" Space+ "long" Space+ "long" {{ 
			    value = getType("unsigned long long"); 
			}}
			| "unsigned" Space+ "long" Spacing {{ 
			    value = getType("unsigned long"); 
			}}

type 		=	unsigned_type
			| signed_type
			| "void" Spacing {{ value = getType("void"); }}

## just ignore the modules ones, not supporting right now

Type_form	=	"projection" Space+ n:Identifier Spacing {{
			    value = getType((char*)n.getValue()); 
			}}
			| "channel" Spacing {{  // todo
			    printf("matched a channel type\n"); 
			    value = new Channel();
			}}
			| type	

Spacing		=	Space*

EndSpacing	=	EndSpace* 

Space		=	" " | "\t" | EndOfLine | Comment | Line_comment

EndSpace	= 	Space | Line_comment

EndOfLine	=	"\n" | "\r"

Comments	= 	Comment | Line_comment

Comment		=	Comment_start Comment_rest

Comment_rest	=	Comment_end
			| . Comment_rest

Comment_start	=	"/*"
Comment_end	=	"*/"


Line_comm_rest	=	Line_comm_end
			| . Line_comm_rest

Line_comm_start	=	"//"

Line_comment	=	Line_comm_start Line_comm_rest

Line_comm_end	=	"\n"

OPEN		=	"("
CLOSE		=	")"
SEMI		=	";"	
OPENC		=	"{"
CLOSEC		=	"}"
OPENA		=	"<"
CLOSEA		=	">"
OPENS		=	"["
CLOSES		=	"]"
COMMA		=	","