start-symbol: File


include: {{ #include "lcd_ast.h"
	    #include "error.h"
	    #include <vector>
	    #include <stdlib.h>
	    #include <string>
	    #include <stdint.h> }}

code: {{
      LexicalScope *current_scope = 0x0;
      LexicalScope *current_module_scope = 0x0;

      void set_current_scope(LexicalScope *ls)
      {
          current_scope = ls;
      }

      LexicalScope* get_current_scope()
      {
          return current_scope;
      }

      void set_current_module_scope(LexicalScope *ls)
      {
          current_module_scope = ls;
      }

      LexicalScope* get_current_module_scope()
      {
          return current_module_scope;
      }

      Type * getType(const char* type)
      {	   
      	   int err;
	   LexicalScope *ls = get_current_scope();
	   Type* val = ls->lookup_symbol(type, &err);
	   if(!val)
	   {	
	   	printf("val is null\n");
	   }
	   
	   if(!err)
	   { 
	     ErrorReport* er = ErrorReport::instance();
	     er->set_error();
	     printf("Error looking up type: %s\n", type);
	     return 0; // continue execution
	   }
	    return val;
      }	

      Type* count_pointers(Value v, const char* type)
      {
	   Type *t = getType(type);
	   
	   for(Value::iterator it = v.getValues().begin(); it != v.getValues().end(); it++)
	   {
		const Value & v = *it;
		char star = (char) (intptr_t) v.getValue();
		if(star == '*')
		{
		 
		 t = new PointerType(t);		
		}
		else
		{
			printf("Not a star\n");
		}
	   }
	   
	   return t;	
      }			

      void insertType(const char * sym, Type * val) // should this be void?
      {
	LexicalScope *ls = get_current_scope();
	bool ret = ls->insert_symbol(sym, val);
	if(!ret)
	{
	    ErrorReport* er = ErrorReport::instance();
	    er->set_error();
	    printf("Error: type by name %s already exists in current scope.\n", type->name());
	}
      }	
}}

rules:


File		=	Spacing v:Verbatim? GlobalScopeDefinitions t:Interface* <eof> {{
			std::vector<Module*> modules;
			// ignore verbatim for now		       
			
			for(Value::iterator it = t.getValues().begin(); it != t.getValues().end(); it ++) {
			    const Value & v2 = *it;
			    Module *m = (Module *) v2.getValue();
			    modules.push_back(m);

			}

			value = new Project(GlobalScope::instance(), modules); }}

GlobalScopeDefinitions =      Spacing d:Type_Definitions* Spacing {{
		       	          for(Value::iterator it = d.getValues().begin(); it != d.getValues().end(); it ++) { 
			    	      const Value & v2 = *it;
			    	      Type *type = (Type*) v2.getValue();
			    	      bool err = GlobalScope::instance()->insert(type->name(), type);
				      if(!err) {
				          printf("Error: definition already exists for a type of name %s in global scope.\n", type->name());
				      }
				  } 
			      }}

ModuleScopeDefinitions       =      Spacing d:Type_Definitions* Spacing {{
		       	          // create a new current scope
				  LexicalScope *new_scope = new LexicalScope(GlobalScope::instance());
				  for(Value::iterator it = d.getValues().begin(); it != d.getValues().end(); it ++) { 
			    	      const Value & v2 = *it;
			    	      Type *type = (Type*) v2.getValue();
			    	      bool err = new_scope->insert(type->name(), type);
				      if(!err) {
				          printf("Error: definition already exists for a type of name %s.\n", type->name());
				      }
				  }
				  set_current_module_scope(new_scope);
				  set_current_scope(new_scope);
				  value = new_scope;
			      }}

ProjectionScopeDefinitions    =		d:Type_Definitions* Spacing {{
			      		    LexicalScope *new_scope = new LexicalScope(get_current_scope());
					    for(Value::iterator it = d.getValues().begin(); it != d.getValues().end(); it ++) {
					        const Value & v2 = *it;
						Type *type = (Type*) v2.getValue();
						bool err = new_scope->insert(type->name(), type);
						if(!err) {
						    printf("Error: definition already exists for a type of name %s.\n", type->name());
						}
					    }
					}}

UnnamedScopeDefinitions       =      Spacing d:Type_Definitions* Spacing {{
		       	          // create a new current scope
				  LexicalScope *new_scope = new LexicalScope(get_current_module_scope());			
				  for(Value::iterator it = d.getValues().begin(); it != d.getValues().end(); it ++) { 
			    	      const Value & v2 = *it;
			    	      Type *type = (Type*) v2.getValue();
			    	      bool err = new_scope->insert(type->name(), type);
				      if(!err) {
				          printf("Error: definition already exists for a type of name %s.\n", type->name());
				      }
				  }
				  set_current_scope(new_scope);
				  value = new_scope;
			      }}


Identifier	=	i1:IdentStart i2:IdentCont* {{ 
			std::ostringstream total;
			total << (char) (intptr_t) i1.getValue();

		   	for(Value::iterator it = i2.getValues().begin(); it != i2.getValues().end(); it ++)
		   	{
				const Value & v = *it;
				char letter = (char) (intptr_t) v.getValue();
				total << letter;
		   	}
				std::string str = total.str();
				printf("identifier is: %s\n", str.c_str());
		   		value.value = malloc(str.length()+1);
				printf("hereeeee\n");
				strncpy((char*)value.value, str.c_str(), str.length()+1); }}

IdentStart	=	[abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ_]

IdentCont	=	IdentStart | [0123456789]

unnamed_scope 	= 	Spacing OPENC Spacing s:UnnamedScopeDefinitions Rpc* Spacing CLOSEC Spacing {{
			    // rpc adds itself to scope.
			    value = s;
			}}

Interface	=	  "interface" Space+ id:Identifier Spacing OPEN globals:Parameters Spacing CLOSE Spacing OPENC Spacing s:ModuleScopeDefinitions Rpc* us:unnamed_scope* Spacing CLOSEC Spacing {{ 
			      LexicalScope *module_scope = (LexicalScope*) s.getValue();

			      for(Value::iterator it = us.getValues().begin(); it != us.getValues().end(); it ++) {
			          const Value & v2 = *it;
				  LexicalScope *ls = (LexicalScope*) v2.getValue();
				  module_scope->add_inner_scope(ls); 
			      }	  
			      value = new Module(module_scope); 
			  }}

Typedef		=	 "typedef" Spacing "<" Spacing rt:RealType Spacing "," Spacing mt:Type_form ">" Spacing id:Identifier Spacing {{ 
			     Typedef * val = new Typedef((char*) rt.getValue(), (Type*) mt.getValue());
			     insertType((char*)id.getValue(),val);
			 }}

Verbatim	=	 "verbatim" Spacing "[" contents:VerbatimContent "]" {{ std::ostringstream total;
			for(Value::iterator it = contents.getValues().begin(); it != contents.getValues().end(); it ++)
			{
			const Value &v = *it;
			char letter = (char) (intptr_t) v.getValue();
			total << letter;     
			}
			std::string str = total.str();
			value = &str[0]; }}

VerbatimContent =	!"]" .

RealType	=	fp:Identifier? Spacing sp:Identifier Spacing {{ //temporary solution
			std::ostringstream total;	     
			total << fp.getValue() << ' ' << sp.getValue();
			std::string str = total.str();
			value = &str[0];
			}}		

String		=	<ascii 34> l:any_letter+ <ascii 34> {{
			std::ostringstream total;
			for(Value::iterator it = l.getValues().begin(); it != l.getValues().end(); it ++)
			{
				const Value & v = *it;
				char letter = (char) (intptr_t) v.getValue();
				
				if(letter == '\\')
				{
					if((it++) == l.getValues().end())
					{
						total << letter;
						break;
					}	
					
					letter = (char) (intptr_t) (*it).getValue();
					switch (letter)
					{
					case 'n':
					     total <<'\n';
					     break;
					case 't':
					     total << '\t';
					     break;
					default:
						total << letter;
					}
					continue;
				}
				total << letter;
			}
			std::string str = total.str();
			value = str.c_str(); }}

any_letter	=	[_.,/?<>'; =:%`!@#$^&*()-+{}|\\ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789]

Type_Definitions =	Typedef | Projection {{ printf("done with projection\n"); }}

Include		 =	"#include" Space+ "<" Spacing f:Identifier Spacing ">" Spacing {{
			std::ostringstream total;
			total << "#include <" << (char *) f.getValue() << ">";
			std::string str = total.str();
			value = str.c_str(); }}
			
			| "#include" Space+ s:String Spacing {{
			std::ostringstream total;
			total << "#include " << (char *) s.getValue();
			std::string str = total.str();
			value = str.c_str(); }}

FP_Parameter	=	"rpc" Space+ rt:Type_form Spacing OPEN Spacing "*" Spacing id:Identifier CLOSE Spacing OPEN p:FP_Parameters CLOSE SEMI {{
			    FunctionPointer *fp = new FunctionPointer((char*) id.getValue(), (Type*) rt.getValue(), (std::vector<FPParameter*>) *p.getValue());
			    value = new Parameter(fp, (char *) id.getValue());
			}}

FirstParam	=	t:Type_form id:Identifier Spacing COMMA Spacing {{
			    value = new Parameter((Type *) t.getValue(), (char *) id.getValue()); 
			}}
			| FP_Parameter Spacing COMMA Spacing

FP_FirstParam	=	t:Type_form Spacing COMMA Spacing {{
			    value = new FPParameter((Type*) t.getValue());  
			}}
			| FP_Parameter Spacing COMMA Spacing
			  
LastParam	=	t:Type_form id:Identifier Spacing {{
			    value = new Parameter((Type *) t.getValue(), (char *) id.getValue()); 
			}}
			| FP_Parameter Spacing

FP_LastParam	=	t:Type_form Spacing {{
			    value = new FPParameter((Type*) t.getValue());
			}}
			| FP_Parameter Spacing

Parameters	=	f:FirstParam* l:LastParam {{
			    std::vector<Parameter* > *params = new std::vector<FPParameter*>();
			    for(Value::iterator it = f.getValues().begin(); it != f.getValues().end(); it ++)
			    { 
			
				const Value & v = *it;
				Parameter* p = (Parameter* ) v.getValue();
				params->push_back(p);
			    }
			    params->push_back((Parameter* ) l.getValue());
			    value = params; 
			}}

FP_Parameters	=	f:FP_FirstParam* l:FP_LastParam {{
			    std::vector<FPParameter* > *params = new std::vector<FPParameter*>();
			    for(Value::iterator it = f.getValues().begin(); it != f.getValues().end(); it ++) { 
			
				const Value & v = *it;
				FPParameter* p = (FPParameter* ) v.getValue();
				params->push_back(p);
			    }
			    params->push_back((FPParameter* ) l.getValue());
			    value = params;
			}}


Rpc		=	"rpc" Space+ t:Type_form id1:Identifier Spacing OPEN p:Parameters CLOSE SEMI Spacing {{
			    std::vector<Parameter*>* params = (std::vector<Parameter*>*) p.getValue();
			    std::vector<Parameter*> params_ = *params;
			    Rpc* r = new Rpc(new ReturnVariable((Type *) t.getValue()), (char *) id1.getValue(), params_);
			    int err = get_current_scope()->insert(r);
			    if(!err) {
			        printf("Error rpc already in scope with this name %s.\n", rpc->name());
		            }
			    value = r; 
			}}

Globals		=	  

Projection_constructor =    "projection" Space+ id:Identifier Spacing "<" Spacing t:Proj_type ">" Spacing OPEN Spacing g:Globals Spacing CLOSE Spacing OPENC Spacing s:ProjectionScopeDefinitions p:ProjField* us:unnamed_scope* Spacing CLOSEC Spacing {{
		       	        ...
			    }} 

Projection	=	"projection" Space+ id:Identifier Spacing "<" Spacing t:Proj_type ">" Spacing OPENC Spacing p:ProjField* CLOSEC Spacing {{ 
			    std::vector<ProjectionField *> p_fields;
			    for(Value::iterator it = p.getValues().begin(); it != p.getValues().end(); it ++)
			    {
				const Value & v = *it;
				ProjectionField * p2 = (ProjectionField *) v.getValue();
				p_fields.push_back(p2);
			    } 
			    ProjectionType * val = new ProjectionType((char* ) id.getValue(), (char* ) t.getValue(), p_fields);
			    insertType((char*)id.getValue(), val);
			    value = val;
			 }}
		## what is the point of having a projection without at least one line

Proj_type	=  	"struct" Space+ id:Identifier Spacing {{
			value = id;}}

Keyword		=     	"out" {{ int * x = (int *) malloc(sizeof(int));
			      *x = 1;
			      value = x; }}
			| "in" {{ int * x = (int *) malloc(sizeof(int));
			       *x = 2; 
			       value = x; }}
			| "bind" {{ int * x = (int *) malloc(sizeof(int));
			  	 *x = 3; 
			  	 value = x; }}
			| "alloc" {{ int * x = (int *) malloc(sizeof(int));
			  	  *x = 4;
				  value = x; }}
			
Start		=	k:Keyword Spacing COMMA Spacing {{ value = k; }}

Specification	=	s:Start* l:Last {{
			std::vector<bool>* specs = new std::vector<bool>(4, false);
			for(Value::iterator it = s.getValues().begin(); it != s.getValues().end(); it ++)
			{
				const Value & v = *it;
				int* x = (int*) v.getValue();
				if(!x)
				{
					printf("error x is null\n");
					exit(0);       
				}
				specs->at(*x -1) = true;
			}
			int * y = (int *) l.getValue();
			if(!y) { printf("error y is null\n"); exit(0); }
			specs->at(*y-1) = true;
			value = specs; }}

ProjField	=	t:Type_form Spacing OPENS Spacing s:Specification CLOSES Spacing id:Identifier Spacing SEMI Spacing {{ 
			    bool in = false; bool out = false; bool bind = false; bool alloc = false;
			    std::vector<bool>* specs = (std::vector<bool>*) s.getValue();
			    printf("In Proj field\n");
			    int i = 0;
			    printf("%zu", specs->size());

			    if(specs->at(0) == true) {
			        out = true;
			    }					
			    if(specs->at(1) == true) {
			        in = true;
			    }					
			    if(specs->at(2) == true) {
			        bind = true;
			    }
			    if(specs->at(3) == true) {
			        alloc = true;
			    }

			    printf("about to construct projection field\n");
			    value = new ProjectionField(in, out, alloc, bind, (Type *) t.getValue(), (char *) id.getValue()); 
			}}
			| "rpc" Space+ rt:Type_form Spacing OPENS Spacing s:Specification CLOSES Spacing OPEN Spacing "*" Spacing id:Identifier CLOSE Spacing OPEN p:FP_Parameters CLOSE SEMI Spacing {{

			    bool in = false; bool out = false; bool bind = false; bool alloc = false;
			    std::vector<bool>* specs = (std::vector<bool>*) s.getValue();
			    printf("In Proj field\n");
			    int i = 0;
			    printf("%zu", specs->size());

			    if(specs->at(0) == true) {
			        out = true;
			    }					
			    if(specs->at(1) == true) {
			        in = true;
			    }					
			    if(specs->at(2) == true) {
			        bind = true;
			    }
			    if(specs->at(3) == true) {
			        alloc = true;
			    }

			    FunctionPointer *fp = new FunctionPointer((char*) id.getValue(), (Type*) rt.getValue(), (std::vector<FPParameter*>) *p.getValue());
			    value = new ProjectionField(in, out, alloc, bind, fp, (char*) id.getValue());
			}}

Last		=	k:Keyword Spacing {{ value = k; }}

Option		=	"projection"

Comment		=	Comment_start Comment_rest

Comment_rest	=	Comment_end
			| . Comment_rest

Comment_start	=	"/*"
Comment_end	=	"*/"


Line_comm_rest	=	Line_comm_end
			| . Line_comm_rest

Line_comm_start	=	"//"

Line_comment	=	Line_comm_start Line_comm_rest


Line_comm_end	=	"\n"

star = [*]

signed_type	=	"int" Space* ps:star* Space+{{ value = count_pointers(ps, "int");}}
			| "char" Space* ps:star* Space+ {{ value = count_pointers(ps, "char"); }}   
			| "capability" Space+ {{ value = getType("capability"); }}
			| "short" Space* ps:star* Space+ {{ value = count_pointers(ps, "short");}}
			| "long"  Space+ "long" Space* ps:star* Space+ {{ value = count_pointers(ps, "long long");}}
			| "long" Space* ps:star* Space+ {{ value = count_pointers(ps, "long"); }}

			| "int" Space+ ps:star* Space*{{ value = count_pointers(ps, "int");}}
			| "char" Space+ ps:star* Space*{{ value = count_pointers(ps, "char"); }}   
			| "short" Space+ ps:star* Space* {{ value = count_pointers(ps, "short");}}
			| "long" Space+ "long" Space+ ps:star* Space* {{ value = count_pointers(ps, "long long");}}
			| "long"  Space+ ps:star* Space*{{ value = count_pointers(ps, "long"); }}

unsigned_type	=	"unsigned" Space+ "int" ps:star* Space+ {{ value = count_pointers(ps, "unsigned int"); }} 
			| "unsigned" Space+ "char" ps:star* Space+ {{ value = count_pointers(ps, "unsigned char"); }} 
			| "unsigned" Space+ "short" ps:star* Space+ {{ value = count_pointers(ps, "unscd teigned long"); }} 
			| "unsigned" Space+ "long" Space+ "long" ps:star* Space+ {{ value = count_pointers(ps, "unsigned long long"); }}
			| "unsigned" Space+ "long" ps:star* Space+ {{ value = count_pointers(ps, "unsigned long"); }}
			| "unsigned" Space+ "int" Space+ ps:star* {{ value = count_pointers(ps, "unsigned int"); }} 
			| "unsigned" Space+ "char" Space+ ps:star* {{ value = count_pointers(ps, "unsigned char"); }} 
			| "unsigned" Space+ "short" Space+ ps:star* {{ value = count_pointers(ps, "unsigned long"); }} 
			| "unsigned" Space+ "long" Space+ "long" Space+ ps:star* {{ value = count_pointers(ps, "unsigned long long"); }}
			| "unsigned" Space+ "long" Space+ ps:star* {{ value = count_pointers(ps, "unsigned long"); }}  
  

type 		=	unsigned_type
			| signed_type
			| "void" Space+ {{ value = getType("void"); }}

## just ignore the modules ones, not supporting right now

Spacing		=	Space*

Type_form	=	"projection" Space+ n:Identifier Space* "*" Spacing {{
			printf("projection pointer name is: %s\n", (char*)n.getValue());
			 printf("calling getType 2\n");
			value = new PointerType(getType((char*)n.getValue())); }}
			| "projection" Space+ name:Identifier Space+ {{ 
			  printf("calling getType 1\n");
			  value = getType((char*)name.getValue()); }}
			| "channel" {{  // todo 
			  }}
			| type	

Space		=	" " | "\t" | EndOfLine
EndOfLine	=	"\n" | "\r"

OPEN		=	"("
CLOSE		=	")"
SEMI		=	";"	
OPENC		=	"{"
CLOSEC		=	"}"
OPENA		=	"<"
CLOSEA		=	">"
OPENS		=	"["
CLOSES		=	"]"
COMMA		=	","