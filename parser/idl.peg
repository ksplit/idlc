start-symbol: file

include: {{
    #include <cstdint>
    #include <string>
    #include <type_traits>

    #include <gsl/gsl>

    #include "ast.h"
    #include "../frontend/string_heap.h"
}}

code: {{
    namespace idlc {
        using namespace ::idlc;
        using id = gsl::czstring<>;

        template<typename type>
        using uptr = std::unique_ptr<type>;

        template<typename type>
        constexpr bool is_arithmetic_v = std::is_arithmetic<type>::value;

        template<typename type>
        constexpr bool is_pointer_v = std::is_pointer<type>::value;

        template<bool enable, typename type>
        using enable_if_t = typename std::enable_if<enable, type>::type;

        template<typename type>
        enable_if_t<is_arithmetic_v<type>, type> unbox(const Value& v) noexcept
        {
            return static_cast<type>(reinterpret_cast<std::uintptr_t>(v.getValue()));
        }

        template<typename type>
        enable_if_t<is_pointer_v<type>, type> unbox(const Value& v)
        {
            const auto ptr = const_cast<void*>(v.getValue());
            return static_cast<type>(ptr);
        }

        template<typename type>
        auto box(type v) noexcept
        {
            static_assert(std::is_trivially_copyable<type>::value, "only trivially copyable types are boxeable");
            static_assert(sizeof(type) <= sizeof(const void*), "can't box something this big");
            return reinterpret_cast<const void*>(v);
        }

        id make_id(string_heap& heap, const Value& first, const Value& rest)
        {
            const auto rest_vals = rest.getValues();

            std::string new_id {};
            new_id.reserve(rest_vals.size() + 1);

            new_id += unbox<char>(first);
            for (const auto next : rest_vals) {
                new_id += unbox<char>(next);
            }

            std::cout << "ID \"" << new_id << "\"" << std::endl;

            return heap.intern(new_id);
        }

        enum class primitive_token : std::uint8_t {
            token_none,
            token_char,
            token_short,
            token_int,
            token_long,
            token_unsigned,
            token_signed
        };
        
        constexpr auto primitive_id(primitive_token d) noexcept
        {
            return static_cast<std::uint32_t>(d);
        }

        constexpr auto primitive_id(primitive_token c, primitive_token d) noexcept
        {
            return (static_cast<std::uint32_t>(c) << (8 * 1)) | primitive_id(d);
        }

        constexpr auto primitive_id(primitive_token b, primitive_token c, primitive_token d) noexcept
        {
            return (static_cast<std::uint32_t>(b) << (8 * 2)) | primitive_id(c, d);
        }

        constexpr auto primitive_id(primitive_token a, primitive_token b, primitive_token c, primitive_token d) noexcept
        {
            return (static_cast<std::uint32_t>(a) << (8 * 3)) | primitive_id(b, c, d);
        }

        enum class parsed_primitive_type {
            invalid,
            char_type = primitive_id(primitive_token::token_char),
            uchar_type = primitive_id(primitive_token::token_unsigned, primitive_token::token_char),
            schar_type = primitive_id(primitive_token::token_signed, primitive_token::token_char),
            short_type = primitive_id(primitive_token::token_short),
            ushort_type = primitive_id(primitive_token::token_unsigned, primitive_token::token_short),
            int_type = primitive_id(primitive_token::token_int),
            uint_type = primitive_id(primitive_token::token_unsigned, primitive_token::token_int),
            long_type = primitive_id(primitive_token::token_long),
            ulong_type = primitive_id(primitive_token::token_unsigned, primitive_token::token_long),
            longlong_type = primitive_id(primitive_token::token_long, primitive_token::token_short),
            ulonglong_type = primitive_id(primitive_token::token_unsigned, primitive_token::token_long, primitive_token::token_long)
        };

        auto recognize_type(const Value& first, const Value& rest)
        {
            const auto& vals = rest.getValues();
            const auto count = vals.size();
            std::uint32_t tag {};
            tag |= (idlc::unbox<std::uint8_t>(first) << (count * 8));
            auto n_byte = count - 1;
            for (const auto& val : vals) {
                tag |= (idlc::unbox<std::uint8_t>(val) << (n_byte * 8));
                --n_byte;
            }

            switch (static_cast<parsed_primitive_type>(tag)) {
            case parsed_primitive_type::char_type: 
            case parsed_primitive_type::uchar_type:
            case parsed_primitive_type::schar_type:
            case parsed_primitive_type::short_type:
            case parsed_primitive_type::ushort_type:
            case parsed_primitive_type::int_type:
            case parsed_primitive_type::uint_type:
            case parsed_primitive_type::long_type: 
            case parsed_primitive_type::ulong_type:
            case parsed_primitive_type::longlong_type:
            case parsed_primitive_type::ulonglong_type:
                return static_cast<parsed_primitive_type>(tag);

            default:
                std::cout << "Unrecognized type" << std::endl;
                return parsed_primitive_type::invalid;
            }
        }
    }
}}

rules:

# Keywords (parser produces better error messages when these are rules, not literals)

const = "const"
string = "string"
projection = "projection"
rpc = "rpc"
driver = "driver"
module = "module"
header = "header"
import = "import"
signature = "signature"
struct = "struct"
union = "union"
char = "char"
short = "short"
int = "int"
long = "long"
signed = "signed"
unsigned = "unsigned"
void = "void"

# Primitive types

component = unsigned {{
    value = idlc::box(idlc::primitive_token::token_unsigned);
}} | signed {{
    value = idlc::box(idlc::primitive_token::token_signed);
}} | long {{
    value = idlc::box(idlc::primitive_token::token_long);
}} | int {{
    value = idlc::box(idlc::primitive_token::token_int);
}} | short {{
    value = idlc::box(idlc::primitive_token::token_short);
}} | char {{
    value = idlc::box(idlc::primitive_token::token_char);
}}

primitive_specifier = first:component rest:(wsp c:component {{ value = c.getValue(); }})* <predicate ok>{{
    // No valid primitive type is longer than 4 components
    const auto& values = rest.getValues();
    ok = values.size() <= 3;
}} {{
    value = idlc::box(idlc::recognize_type(first, rest));
}}

# Utility rules

blank = [ \n\t] | comment
wsp = blank*
sp = wsp?

letter = [abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ]
number = [0123456789]

line_comment = "//" .* "\n"
comment = line_comment

# Identifiers

id_start = "_" {{ value = idlc::box('_'); }} | letter
id_next = id_start | number
id(ctx) = first:id_start rest:id_next* {{
    const gsl::not_null<idlc::string_heap*> strings {idlc::unbox<idlc::string_heap*>(ctx)};
    value = idlc::make_id(*strings, first, rest);
}}

# Driver block

module_import(ctx) = import sp id(ctx) sp ";" sp
driver_definition(ctx) = driver wsp id(ctx) sp "{" sp module_import(ctx)* "}" sp

# Header statement

header_path = "<" header_path_tail
header_path_tail = ">" | . header_path_tail
header_import = header sp header_path ";" sp

# Attributes

attr_list = "[" sp attributes "]"
attributes = attribute sp attributes_tail
attributes_tail = "," sp attribute sp attributes_tail | <void>
attribute = "alloc(caller)" | "alloc(callee)" | "bind(caller)" | "bind(callee)" | "dealloc(caller)" | "dealloc(callee)"

# Types
# Due to the unfortunate nature of left-recursion, and the fact that we have to deal with whitespace,
# the parser includes the parsing of indirections into each specific rule
# notice that these rules enforce that projection are always pointer type, along with strings
# Primtive types are always value types, as are rpcs, as they are not treated as other
# pointers are

indirection = (attr_list sp)? "*"
indirection_spacer = sp indirection sp | wsp

void_type = void
string_type = string sp indirection
string_var(ctx) = string_type sp id(ctx)
projection_type(ctx) = projection wsp id(ctx) sp indirection
projection_var(ctx) = projection_type(ctx) sp id(ctx)
primitive_type = primitive_specifier
primitive_var(ctx) = primitive_type wsp id(ctx)
rpc_type(ctx) = rpc wsp id(ctx)
rpc_var(ctx) = rpc_type(ctx) wsp id(ctx)

# Projection fields

variable(ctx) = primitive_var(ctx) | projection_var(ctx) | string_var(ctx) | rpc_var(ctx)
projection_field(ctx) = variable(ctx) sp ";" sp

# Projection block

struct_tag(ctx) = struct wsp id(ctx) sp
union_tag(ctx) = union wsp id(ctx) sp
type_tag(ctx) = struct_tag(ctx) | union_tag(ctx)
projection_definition(ctx) = projection sp "<" sp type_tag(ctx) ">" sp id(ctx) sp "{" sp projection_field(ctx)* "}" sp

# RPC block

arguments(ctx) = variable(ctx) sp arguments_tail(ctx)
arguments_tail(ctx) = "," sp arguments(ctx) | <void>
return_type(ctx) = void_type | string_type | projection_type(ctx) | primitive_type | rpc_type(ctx)
rpc_signature(ctx) = signature wsp return_type(ctx) sp "(" sp arguments(ctx)? ")" sp ";" sp
rpc_item(ctx) = projection_definition(ctx) | rpc_signature(ctx)
rpc_definition(ctx) = rpc wsp id(ctx) sp "{" sp rpc_item(ctx)* "}" sp

# Module block

module_item(ctx) = rpc_definition(ctx) | projection_definition(ctx) | header_import
module_definition(ctx) = module wsp id(ctx) sp "{" sp module_item(ctx)* "}" sp

# File structure

driver_file(ctx) = sp driver_definition(ctx) <eof>
module_file(ctx) = sp module_definition(ctx)+ <eof>

file_inner(ctx) = driver_file(ctx) | module_file(ctx)
file = ctx:{{
    value = std::make_unique<idlc::string_heap>().release();
}} file_inner(ctx) {{
    idlc::uptr<idlc::string_heap> ptr {idlc::unbox<idlc::string_heap*>(ctx)};
    ptr.reset();
}}
