start-symbol: file

include: {{
    #include <cstdint>
    #include <string>
    #include <type_traits>
    #include <vector>

    #include <gsl/gsl>

    #include "ast.h"
    #include "string_heap.h"
}}

code: {{
    namespace idlc {
        using namespace ::idlc;

        template<typename type>
        using uptr = std::unique_ptr<type>;
    }
}}

rules:

# Keywords (parser produces better error messages when these are rules, not literals)

const = "const"
string = "string"
projection = "projection"
rpc = "rpc"
driver = "driver"
module = "module"
header = "header"
import = "import"
signature = "signature"
struct = "struct"
union = "union"
char = "char"
short = "short"
int = "int"
long = "long"
signed = "signed"
unsigned = "unsigned"
void = "void"
include = "include"
array = "array"
null = "null"

# Primitive types

component = unsigned | signed | long | int | short | char

# NOTE: no valid primitive specifier is longer than 4
primitive_specifier = first:component rest:(wsp c:component)*

# Utility rules

blank = [ \n\t] | comment
wsp = blank*
sp = wsp?

letter = [abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ]
number = [0123456789]

line_comment = "//" .* "\n"
comment = line_comment

# Identifiers

id_start = "_" | letter
id_next = id_start | number
id(ctx) = first:id_start rest:id_next* 

# Driver block

module_import(ctx) = import sp id:id(ctx) sp ";" sp

driver_definition(ctx) = driver wsp id:id(ctx) sp "{" sp imports:module_import(ctx)* "}" sp

# Header statement

path(ctx) = "<" path_tail

path_tail = ">" | . path_tail

header_import(ctx) = header sp pt:path(ctx) sp ";" sp

idl_include(ctx) = include sp pt:path(ctx) sp ";" sp

# Attributes

attribute_set = "[" sp attrs:attributes "]"

attributes = new_attrs:attribute sp attrs:attributes_tail

attributes_tail = "," sp new_attrs:attribute sp attrs:attributes_tail | <void>

attribute = "alloc(caller)" | "alloc(callee)" | "bind(caller)" | "bind(callee)" | "dealloc(caller)" | "dealloc(callee)" | "in" | "out"

# Types

indirection = (attrs:attribute_set sp)? "*"
type_tail = stars:(sp flags:indirection sp)+ sp attrs:attribute_set? | sp attrs:attribute_set

type_tail_spacer = set:type_tail | wsp

void_type = void

string_type = string

projection_type(ctx) = projection wsp id:id(ctx)

rpc_type(ctx) = rpc wsp id:id(ctx)

primitive_type = ty:primitive_specifier

# FIXME: these generate void_type AST nodes rn
# NOTE: PEG parsers cache parse results, so it's not safe to free pointers in here in general

array_type(ctx) = array "<" sp type_name(ctx) sp "," sp null sp ">" | array "<" sp type_name(ctx) sp "," sp number sp ">" | array "<" sp type_name(ctx) sp "," sp value_ref(ctx) sp ">"

spaced_stem_type(ctx) = ty:void_type | ty:string_type | ty:primitive_type | ty:rpc_type(ctx) | ty:projection_type(ctx)

unspaced_stem_type(ctx) = ty:array_type(ctx)

type_name(ctx) = ty:spaced_stem_type(ctx) attrs:type_tail | ty:unspaced_stem_type(ctx) attrs:type_tail

# The one that requires correct spacing
type_specifier(ctx) = ty:spaced_stem_type(ctx) attrs:type_tail_spacer | ty:unspaced_stem_type(ctx) sp attrs:type_tail? sp

# Projection fields

variable(ctx) = ty:type_specifier(ctx) id:id(ctx)

projection_field(ctx) = var:variable(ctx) sp ";" sp

# Projection block

value_ref(ctx) = id(ctx) ("->" id(ctx))* # Have to identify "this" keyword in passes
struct_tag(ctx) = struct wsp id:id(ctx) sp
union_tag(ctx) = union wsp id(ctx) sp "," sp value_ref(ctx) sp
type_tag(ctx) = struct_tag(ctx) | union_tag(ctx)
projection_definition(ctx) = projection sp "<" sp type_tag(ctx) ">" sp id(ctx) sp "{" sp projection_field(ctx)* "}" sp

# RPC block

arguments(ctx) = variable(ctx) sp arguments_tail(ctx)
arguments_tail(ctx) = "," sp arguments(ctx) | <void>
rpc_signature(ctx) = signature wsp type_specifier(ctx) sp "(" sp arguments(ctx)? ")" sp ";" sp
rpc_item(ctx) = projection_definition(ctx) | rpc_signature(ctx)
rpc_definition(ctx) = rpc wsp id(ctx) sp "{" sp rpc_item(ctx)* "}" sp

# Module block

module_item(ctx) = rpc_definition(ctx) | projection_definition(ctx) | header_import(ctx)
module_definition(ctx) = module wsp id(ctx) sp "{" sp module_item(ctx)* "}" sp

# File structure

# An incredibly ugly hack, but I would like to see a single person who puts includes *after* their code
driver_file(ctx) = sp incs:idl_include(ctx)* sp def:driver_definition(ctx) <eof>

module_file(ctx) = sp module_definition(ctx)+ <eof>

file_inner(ctx) = file:driver_file(ctx) | module_file(ctx)

file = ctx:{{
    value = std::make_unique<idlc::string_heap>().release();
}} file:file_inner(ctx) {{
    delete reinterpret_cast<const idlc::string_heap*>(ctx.getValue());
}}
