start-symbol: file

include: {{
    #include <cstdint>
    #include <string>
    #include <type_traits>
    #include <vector>

    #include <gsl/gsl>

    #include "ast.h"
    #include "string_heap.h"
}}

code: {{
    namespace idlc {
        using namespace ::idlc;
        using id = gsl::czstring<>;

        template<typename type>
        using uptr = std::unique_ptr<type>;

        template<typename type>
        constexpr bool is_arithmetic_v = std::is_arithmetic<type>::value;

        template<typename type>
        constexpr bool is_pointer_v = std::is_pointer<type>::value;

        template<bool enable, typename type>
        using enable_if_t = typename std::enable_if<enable, type>::type;

        template<typename type>
        enable_if_t<is_arithmetic_v<type>, type> unbox(const Value& v) noexcept
        {
            return static_cast<type>(reinterpret_cast<std::uintptr_t>(v.getValue()));
        }

        template<typename type>
        enable_if_t<is_pointer_v<type>, type> unbox(const Value& v)
        {
            const auto ptr = const_cast<void*>(v.getValue());
            return static_cast<type>(ptr);
        }

        template<typename type>
        auto box(type v) noexcept
        {
            static_assert(std::is_trivially_copyable<type>::value, "only trivially copyable types are boxeable");
            static_assert(sizeof(type) <= sizeof(const void*), "can't box something this big");
            return reinterpret_cast<const void*>(v);
        }

        id make_id(string_heap& heap, const Value& first, const Value& rest)
        {
            const auto rest_vals = rest.getValues();

            std::string new_id {};
            new_id.reserve(rest_vals.size() + 1);

            new_id += unbox<char>(first);
            for (const auto next : rest_vals) {
                new_id += unbox<char>(next);
            }

            std::cout << "ID \"" << new_id << "\"" << std::endl;

            return heap.intern(new_id);
        }

        enum class primitive_token : std::uint8_t {
            token_none,
            token_char,
            token_short,
            token_int,
            token_long,
            token_unsigned,
            token_signed
        };
        
        constexpr auto primitive_id(primitive_token d) noexcept
        {
            return static_cast<std::uint32_t>(d);
        }

        constexpr auto primitive_id(primitive_token c, primitive_token d) noexcept
        {
            return (static_cast<std::uint32_t>(c) << (8 * 1)) | primitive_id(d);
        }

        constexpr auto primitive_id(primitive_token b, primitive_token c, primitive_token d) noexcept
        {
            return (static_cast<std::uint32_t>(b) << (8 * 2)) | primitive_id(c, d);
        }

        constexpr auto primitive_id(primitive_token a, primitive_token b, primitive_token c, primitive_token d) noexcept
        {
            return (static_cast<std::uint32_t>(a) << (8 * 3)) | primitive_id(b, c, d);
        }

        enum class parsed_primitive_type {
            invalid,
            char_type = primitive_id(primitive_token::token_char),
            uchar_type = primitive_id(primitive_token::token_unsigned, primitive_token::token_char),
            schar_type = primitive_id(primitive_token::token_signed, primitive_token::token_char),
            short_type = primitive_id(primitive_token::token_short),
            ushort_type = primitive_id(primitive_token::token_unsigned, primitive_token::token_short),
            int_type = primitive_id(primitive_token::token_int),
            uint_type = primitive_id(primitive_token::token_unsigned, primitive_token::token_int),
            long_type = primitive_id(primitive_token::token_long),
            ulong_type = primitive_id(primitive_token::token_unsigned, primitive_token::token_long),
            longlong_type = primitive_id(primitive_token::token_long, primitive_token::token_short),
            ulonglong_type = primitive_id(primitive_token::token_unsigned, primitive_token::token_long, primitive_token::token_long)
        };

        auto recognize_type(const Value& first, const Value& rest)
        {
            const auto& vals = rest.getValues();
            const auto count = vals.size();
            std::uint32_t tag {};
            tag |= (idlc::unbox<std::uint8_t>(first) << (count * 8));
            auto n_byte = count - 1;
            for (const auto& val : vals) {
                tag |= (idlc::unbox<std::uint8_t>(val) << (n_byte * 8));
                --n_byte;
            }

            switch (static_cast<parsed_primitive_type>(tag)) {
            case parsed_primitive_type::char_type: 
            case parsed_primitive_type::uchar_type:
            case parsed_primitive_type::schar_type:
            case parsed_primitive_type::short_type:
            case parsed_primitive_type::ushort_type:
            case parsed_primitive_type::int_type:
            case parsed_primitive_type::uint_type:
            case parsed_primitive_type::long_type: 
            case parsed_primitive_type::ulong_type:
            case parsed_primitive_type::longlong_type:
            case parsed_primitive_type::ulonglong_type:
                return static_cast<parsed_primitive_type>(tag);

            default:
                std::cout << "Unrecognized type" << std::endl;
                return parsed_primitive_type::invalid;
            }
        }
    }
}}

rules:

# Keywords (parser produces better error messages when these are rules, not literals)

const = "const"
string = "string"
projection = "projection"
rpc = "rpc"
driver = "driver"
module = "module"
header = "header"
import = "import"
signature = "signature"
struct = "struct"
union = "union"
char = "char"
short = "short"
int = "int"
long = "long"
signed = "signed"
unsigned = "unsigned"
void = "void"
include = "include"

# Primitive types

component = unsigned {{
    value = idlc::box(idlc::primitive_token::token_unsigned);
}} | signed {{
    value = idlc::box(idlc::primitive_token::token_signed);
}} | long {{
    value = idlc::box(idlc::primitive_token::token_long);
}} | int {{
    value = idlc::box(idlc::primitive_token::token_int);
}} | short {{
    value = idlc::box(idlc::primitive_token::token_short);
}} | char {{
    value = idlc::box(idlc::primitive_token::token_char);
}}

primitive_specifier = first:component rest:(wsp c:component {{ value = c.getValue(); }})* <predicate ok>{{
    // No valid primitive type is longer than 4 components
    const auto& values = rest.getValues();
    ok = values.size() <= 3;
}} {{
    value = idlc::box(idlc::recognize_type(first, rest));
}}

# Utility rules

blank = [ \n\t] | comment
wsp = blank*
sp = wsp?

letter = [abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ]
number = [0123456789]

line_comment = "//" .* "\n"
comment = line_comment

# Identifiers

id_start = "_" {{ value = idlc::box('_'); }} | letter
id_next = id_start | number
id(ctx) = first:id_start rest:id_next* {{
    const gsl::not_null<idlc::string_heap*> strings {idlc::unbox<idlc::string_heap*>(ctx)};
    value = idlc::make_id(*strings, first, rest);
}}

# Driver block

module_import(ctx) = import sp id:id(ctx) sp ";" sp {{
    const idlc::module_import imp {
        idlc::unbox<idlc::id>(id)
    };

    value = std::make_unique<idlc::module_import>(imp).release();
}}

driver_definition(ctx) = driver wsp id:id(ctx) sp "{" sp imports:module_import(ctx)* "}" sp {{
    const auto& vals = imports.getValues();
    std::vector<idlc::module_import> import_vec {};
    import_vec.reserve(vals.size());
    for (const auto& val : vals) {
        const gsl::not_null import_ptr {idlc::unbox<idlc::module_import*>(val)};
        idlc::uptr<idlc::module_import> import {import_ptr};
        import_vec.push_back(*import);
        import.reset();
    }

    const idlc::driver_definition def {idlc::unbox<idlc::id>(id), import_vec};
    value = std::make_unique<idlc::driver_definition>(def).release();
}}

# Header statement

path(ctx) = str:{{ value = std::make_unique<std::string>().release(); }} "<" path_tail(str) {{
    idlc::uptr<std::string> text {idlc::unbox<std::string*>(str)};
    const gsl::not_null<idlc::string_heap*> strings {idlc::unbox<idlc::string_heap*>(ctx)};
    const auto path_id = strings->intern(*text);
    std::cout << "PATH " << path_id << std::endl;
    text.release();
    value = path_id;
}}

path_tail(str) = ">" | ch:. {{
    const auto c = idlc::unbox<char>(ch);
    gsl::not_null<std::string*> text {idlc::unbox<std::string*>(str)};
    *text += c;
}} path_tail(str)

header_import(ctx) = header sp path(ctx) sp ";" sp
idl_include(ctx) = include sp path(ctx) sp ";" sp

# Attributes

attr_list = "[" sp attributes "]"
attributes = attribute sp attributes_tail
attributes_tail = "," sp attribute sp attributes_tail | <void>
attribute = "alloc(caller)" | "alloc(callee)" | "bind(caller)" | "bind(callee)" | "dealloc(caller)" | "dealloc(callee)" | "in" | "out"

# Types

indirection = (attr_list sp)? "*"
indirections = (sp indirection sp)+
indirections_spacer = indirections | wsp

attr_spacer = sp attr_list sp | wsp

void_type = void
string_type = string
projection_type(ctx) = projection wsp id(ctx)
rpc_type(ctx) = rpc wsp id(ctx)
primitive_type = primitive_specifier

type_name(ctx) = void_type | string_type | primitive_type | rpc_type(ctx) | projection_type(ctx)

spaced_type(ctx) = void_type | string_type | primitive_type | rpc_type(ctx) | projection_type(ctx)

# The one that requires correct spacing
type_specifier(ctx) = spaced_type(ctx) indirections_spacer

# Projection fields

variable(ctx) = type_specifier(ctx) id(ctx)
projection_field(ctx) = variable(ctx) sp ";" sp

# Projection block

value_ref(ctx) = id(ctx) ("->" id(ctx))* # Have to identify "this" keyword in passes
struct_tag(ctx) = struct wsp id(ctx) sp
union_tag(ctx) = union wsp id(ctx) sp "," sp value_ref(ctx) sp
type_tag(ctx) = struct_tag(ctx) | union_tag(ctx)
projection_definition(ctx) = projection sp "<" sp type_tag(ctx) ">" sp id(ctx) sp "{" sp projection_field(ctx)* "}" sp

# RPC block

arguments(ctx) = variable(ctx) sp arguments_tail(ctx)
arguments_tail(ctx) = "," sp arguments(ctx) | <void>
rpc_signature(ctx) = signature wsp type_specifier(ctx) sp "(" sp arguments(ctx)? ")" sp ";" sp
rpc_item(ctx) = projection_definition(ctx) | rpc_signature(ctx)
rpc_definition(ctx) = rpc wsp id(ctx) sp "{" sp rpc_item(ctx)* "}" sp

# Module block

module_item(ctx) = rpc_definition(ctx) | projection_definition(ctx) | header_import(ctx)
module_definition(ctx) = module wsp id(ctx) sp "{" sp module_item(ctx)* "}" sp

# File structure

# An incredibly ugly hack, but I would like to see a single person who puts includes *after* their code
driver_file(ctx) = sp idl_include(ctx)* sp driver_definition(ctx) <eof>
module_file(ctx) = sp module_definition(ctx)+ <eof>

file_inner(ctx) = driver_file(ctx) | module_file(ctx)
file = ctx:{{
    value = std::make_unique<idlc::string_heap>().release();
}} file_inner(ctx) {{
    idlc::uptr<idlc::string_heap> ptr {idlc::unbox<idlc::string_heap*>(ctx)};
    ptr.reset();
}}
