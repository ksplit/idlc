start-symbol: file

include: {{
	#include "../frontend/string_heap.h"
	#include "ast.h"

	#include <sstream>
	#include <vector>
}}

code: {{
	using namespace ::idlc;

	template<typename type>
	using uptr = std::unique_ptr<type>;

	template<typename type>
	auto unwrap_uptr(const Value& val)
	{
		const auto cptr = reinterpret_cast<const type*>(val.getValue());
		return uptr<type> {const_cast<type*>(cptr)};
	}

	inline void* wrap(compact_attribute v) noexcept
	{
		void* tmp;
		std::memcpy(&tmp, &v, sizeof(v));
		return tmp;
	}

	inline compact_attribute unwrap_compact_attrib(const Value& val) noexcept
	{
		compact_attribute v;
		const auto ptr = val.getValue();
		std::memcpy(&v, &ptr, sizeof(v));
		return v;
	}

	string_heap strings;
}}

rules:

line_comment = "//" line_comment_tail
line_comment_tail = line_comment_end | . line_comment_tail
line_comment_end = newline

block_comment = "/*" block_comment_tail
block_comment_tail = "*/" | . block_comment_tail

comment = line_comment | block_comment
newline = "\n" | "\r" "\n"
space = [ \t] | newline | comment
whitespace = space+
ident_start = [abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ_]
ident_cont = ident_start | [0123456789]
identifier = sc:ident_start rcs:ident_cont* {{
	std::stringstream str;
	str << (char)(std::uintptr_t)sc.getValue();
	for (const auto& v : rcs.getValues()) {
		str << (char)(std::uintptr_t)v.getValue();
	}

	value = strings.intern(str.str().c_str());
}}

digit = [0123456789]
number = digits:digit+ {{
	std::uint64_t n = 0;
	for (const auto v : digits.getValues()) {
		n = n * 10 + (std::uint64_t)v.getValue();
	}

	value = (void*)n;
}}

rpc_kw = "rpc"
int_kw = "int"
short_kw = "short"
long_kw = "long"
char_kw = "char"
bool_kw = "bool"
float_kw = "float"
double_kw = "double"
void_kw = "void"
unsigned_kw = "unsigned"
signed_kw = "signed"
in_kw = "in"
out_kw = "out"
alloc_kw = "alloc"
dealloc_kw = "dealloc"
caller_kw = "caller"
callee_kw = "callee"
proj_kw = "projection"
struct_kw = "struct"
bind_kw = "bind"
module_kw = "module"
require_kw = "require"
include_kw = "include"
union_kw = "union"
import_kw = "import"

oparen = "("
cparen = ")"
obracket = "["
cbracket = "]"
obrace = "{"
cbrace = "}"
oangle = "<"
cangle = ">"
semi = ";"
comma = ","
star = "*"

# We don't actually need the exact primitive type involved *most* of the time
# (Notable exception for possible packing optimization, i.e., need to know the type size)
# C maps multiple different token sequences to the same data types, and don't look parseable by PEGs
# So just track a token list, and then pattern-match in an AST walk to recognize the actual type

# to simplify parsing, whitespace requirements are in the type rules
# note that though the grammar allows annotations on all indirections
# current semantics give only the "topmost" ones meaning

# there's really only 3 basic type categories: primitive, void, and projection

projection_type = proj_kw whitespace id:identifier {{
	value = new projection_type((gsl::czstring<>)id.getValue());
}} # NOTE: empty projections are required for 2-level indirection (??)

copy_type = void_kw {{
	value = nullptr;
}} | proj:projection_type {{
	value = new copy_type {unwrap_uptr<projection_type>(proj)};
}}

type = ct:copy_type attrs:space_or_attribs stars:(star space*)+ {{
	value = new type(
		unwrap_uptr<copy_type>(ct),
		unwrap_uptr<attributes>(attrs),
		gsl::narrow_cast<unsigned int>(stars.getValues().size())
	);
}} | ct:copy_type attrs:space_or_attribs {{
	value = new type(
		unwrap_uptr<copy_type>(ct),
		unwrap_uptr<attributes>(attrs),
		0
	);
}}

wtype = ct:copy_type attrs:space_or_attribs stars:(star space*)+ {{
	value = new type(
		unwrap_uptr<copy_type>(ct),
		unwrap_uptr<attributes>(attrs),
		gsl::narrow_cast<unsigned int>(stars.getValues().size())
	);
}} | ct:copy_type attrs:wspace_or_attribs {{
	value = new type(
		unwrap_uptr<copy_type>(ct),
		unwrap_uptr<attributes>(attrs),
		0
	);
}}

container_side = caller_kw {{ value = (void*)rpc_side::caller; }} | callee_kw {{ value = (void*)rpc_side::callee; }}
attrib_side = space* oparen space* side:container_side space* cparen {{ value = side.getValue(); }} | <void> {{ value = (void*)rpc_side::both; }}
alloc_attrib = alloc_kw side:attrib_side {{
	const auto call_side = (rpc_side)(std::uintptr_t)side.getValue();
	value = wrap(compact_attribute {call_side, attribute_type::alloc});
}}

dealloc_attrib = dealloc_kw side:attrib_side {{
	const auto call_side = (rpc_side)(std::uintptr_t)side.getValue();
	value = wrap(compact_attribute {call_side, attribute_type::dealloc});
}}

bind_attrib = bind_kw side:attrib_side {{
	const auto call_side = (rpc_side)(std::uintptr_t)side.getValue();
	value = wrap(compact_attribute {call_side, attribute_type::bind});
}}

attribute = in_kw {{
	value = wrap(compact_attribute {rpc_side::callee, attribute_type::copy});
}} | out_kw {{
	value = wrap(compact_attribute {rpc_side::caller, attribute_type::copy});
}} | attr:alloc_attrib {{
	value = attr.getValue();
}} | attr:dealloc_attrib {{
	value = attr.getValue();
}} | attr:bind_attrib {{
	value = attr.getValue();
}}

attrib_list = a:attribute space* tail:attrib_list_tail <predicate no_dups>{{
	auto& list = *(std::vector<compact_attribute>*)tail.getValue();
	const auto attrib = unwrap_compact_attrib(a);
	no_dups = true;
	for (const auto existing : list) {
		if (existing == attrib) {
			std::cout << "Error: encountered duplicate attribute while parsing\n";
			no_dups = false;
		}
	}
}} {{
	auto& list = *(std::vector<compact_attribute>*)tail.getValue();
	const auto attrib = unwrap_compact_attrib(a);
	list.push_back(attrib);
	value = tail.getValue();
}}

attrib_list_tail = comma space* list:attrib_list {{
	value = list.getValue();
}} | <void> {{ 
	value = new std::vector<compact_attribute> {};	
}}

attributes = obracket space* list:attrib_list space* cbracket tmp:{{
	auto& attrib_list = *(std::vector<compact_attribute>*)list.getValue();
	value = [&attrib_list]() -> void* {
		const auto obj = attributes::make(attrib_list);
		if (obj) {
			return new attributes(obj.value());
		}
		else {
			return nullptr;
		}
	}();
	delete &attrib_list;
}} <predicate valid>{{
	valid = tmp.getValue();
}}

wspace_or_attribs =  space* attrs:attributes space* {{ value = attrs.getValue(); }} | whitespace {{ value = nullptr; }}
space_or_attribs = space* attrs:attributes space* {{ value = attrs.getValue(); }} | space* {{ value = nullptr; }}

rpc_pseudo_field = rpc_kw attrs:wspace_or_attribs ret_field:pseudo_field oparen space* star space* cparen space* oparen space* args:arg_list space* cparen space* {{
	auto& vec = *(std::vector<uptr<field>>*)args.getValue();
	std::reverse(begin(vec), end(vec));
	auto sig = std::make_unique<signature>(
		uptr<field>((field*)ret_field.getValue()),
		move(vec));
	delete &vec;
	value = new rpc_field(nullptr, move(sig), uptr<attributes> {(attributes*)attrs.getValue()});
}}

const_size = obracket space* n:number space* cbracket
dyn_size = obracket space* id:identifier space* cbracket
size = const_size | dyn_size

var_pseudo_field = ty:type (size space*)* {{
	value = new var_field(nullptr, uptr<type>((type*)ty.getValue()));
}}

# these are the return fields
pseudo_field = rf:rpc_pseudo_field {{
	value = new field(uptr<rpc_field>((rpc_field*)rf.getValue()));
}} | vf:var_pseudo_field {{
	value = new field(uptr<var_field>((var_field*)vf.getValue()));
}}

wspace_var_pseudo_field = ty:wtype (size space*)* {{
	value = new var_field(nullptr, uptr<type>((type*)ty.getValue()));
}}

# these are the return fields
wspace_pseudo_field = rf:rpc_pseudo_field {{
	value = new field(uptr<rpc_field>((rpc_field*)rf.getValue()));
}} | vf:wspace_var_pseudo_field {{
	value = new field(uptr<var_field>((var_field*)vf.getValue()));
}}

rpc_ptr_ident = oparen space* star space* id:identifier space* cparen {{ value = id.getValue(); }}
rpc_ptr = rpc_kw attrs:wspace_or_attribs ret_field:pseudo_field id:rpc_ptr_ident space* oparen space* args:arg_list space* cparen {{
	auto& vec = *(std::vector<uptr<field>>*)args.getValue();
	std::reverse(begin(vec), end(vec));
	auto sig = std::make_unique<signature>(
		uptr<field>((field*)ret_field.getValue()),
		move(vec));
	delete &vec;
	value = new rpc_field((gsl::czstring<>)id.getValue(), move(sig), uptr<attributes> {(attributes*)attrs.getValue()});
}}

rpc_decl = rpc_kw whitespace ret_field:wspace_pseudo_field id:identifier space* oparen space* args:arg_list space* cparen space* semi {{
	auto& vec = *(std::vector<uptr<field>>*)args.getValue();
	std::reverse(begin(vec), end(vec));
	auto sig = std::make_unique<signature>(
		uptr<field>((field*)ret_field.getValue()),
		move(vec));
	delete &vec;
	value = new rpc((gsl::czstring<>)id.getValue(), move(sig));
}}

arg_list = arg:argument space* v:arg_list_tail{{
	auto& vec = *(std::vector<uptr<field>>*)v.getValue();
	vec.emplace_back(uptr<field>((field*)arg.getValue()));
	value = &vec;
}} | <void> {{
	value = new std::vector<uptr<field>>();
}}

arg_list_tail = comma space* v:arg_list {{
	value = v.getValue();
}} | <void> {{
	value = new std::vector<uptr<field>>();
}}

argument = rf:rpc_ptr {{
	value = new field(uptr<rpc_field>((rpc_field*)rf.getValue()));
}} | ty:wtype id:identifier (space* size)* {{
	value = new field(std::make_unique<var_field>((gsl::czstring<>)id.getValue(), uptr<type>((type*)ty.getValue())));
}}

projection_rpc_field = ptr:rpc_ptr space* semi {{
	value = ptr.getValue();
}}

projection_var_field = ty:wtype id:identifier space* (size space*)* semi {{
	value = new var_field((gsl::czstring<>)id.getValue(), uptr<type>((type*)ty.getValue()));
}}

proj_field = rf:projection_rpc_field {{
	value = new field(uptr<rpc_field>((rpc_field*)rf.getValue()));
}} | vf:projection_var_field {{
	value = new field(uptr<var_field>((var_field*)vf.getValue()));
}}

proj_underlying = struct_kw whitespace under:identifier {{
	value = under.getValue();
}} | union_kw whitespace under:identifier {{
	value = under.getValue();
}}

projection = proj_kw space* oangle space* under:proj_underlying space* cangle space* id:identifier space* obrace space* pfs:(pf:proj_field space* {{
	value = pf.getValue();
}})* cbrace {{
	std::vector<uptr<field>> ptrs;
	for (const auto& v : pfs.getValues()) {
		ptrs.push_back(uptr<field> {(field*)v.getValue()});
	}

	value = new projection((gsl::czstring<>)id.getValue(), (gsl::czstring<>)under.getValue(), move(ptrs));
}}

require = require_kw whitespace id:identifier space* semi {{
	value = new require((gsl::czstring<>)id.getValue());
}}

header_import = import_kw space* oangle chs:path_char* cangle newline {{
	std::string str;
	for (const auto& ch : chs.getValues()) {
		str.push_back((char)(std::uintptr_t)ch.getValue());
	}

	value = new header_import(strings.intern(str));
}}

item = v:rpc_decl {{
	value = new module_item(uptr<rpc>((rpc*)v.getValue()));
}} | v:projection {{
	value = new module_item(uptr<projection>((projection*)v.getValue()));
}} | v:require {{
	value = new module_item(uptr<require>((require*)v.getValue()));
}} |  v:header_import {{
	value = new module_item(uptr<header_import>((header_import*)v.getValue()));
}}

module = module_kw whitespace id:identifier space* obrace space* items:(i:item space* {{ value = i.getValue(); }})* cbrace {{
	std::vector<uptr<module_item>> ptrs;
	for (const auto& v : items.getValues()) {
		ptrs.push_back(uptr<module_item> {(module_item*)v.getValue()});
	}

	value = new module {(gsl::czstring<>)id.getValue(), std::move(ptrs)};
}}

path_char = [0123456789abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ_-/.]

# temporarily broken: trailing space after an include TODO
include = include_kw space* oangle chs:path_char* cangle newline {{
	std::string str;
	for (const auto& ch : chs.getValues()) {
		str.push_back((char)(std::uintptr_t)ch.getValue());
	}

	value = new include(std::filesystem::u8path(str));
}}

file_item = i:include {{
	value = new file_item(uptr<include>((include*)i.getValue()));
}} | m:module {{
	value = new file_item(uptr<module>((module*)m.getValue()));
}}

file = space* items:(i:file_item space* {{ value = i.getValue(); }})* <eof> {{
	std::vector<uptr<file_item>> ptrs;
	for (const auto& v : items.getValues()) {
		ptrs.emplace_back(uptr<file_item> {(file_item*)v.getValue()});
	}

	value = new file {std::move(ptrs)};
}}